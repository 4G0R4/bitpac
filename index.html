<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, user-scalable=no">
        <title>Bitpac | Publicly auditable cooperatives on bitcoin</title>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/bitcoinjs-lib.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script>
        <script src="https://supertestnet.github.io/blind-sig-js/blindSigJS.js"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://unpkg.com/@cmdcode/tapscript@1.4.0"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script src="https://bundle.run/buffer@6.0.3"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <style>
            * {
                box-sizing: border-box;
                font-size: 1.15rem;
                font-family: Arial, sans-serif;
            }
            html {
                max-width: 70ch;
                padding: 3rem 1rem;
                margin: auto;
                line-height: 1.25;
            }
            body {
                background-color: #fffdf0;
            }
            h1 {
                font-size: 2rem;
            }
            h2 {
                font-size: 1.5rem;
            }
            input, textarea {
                line-height: 1.25;
                width: 100%;
                height: 1.8rem;
                font-size: 1.15rem;
                border: 1px solid grey;
            }
            textarea {
                height: 8rem;
            }
            .hidden {
                display: none !important;
            }
            .multisig_viewer, .balance, .statements, .current_proposals,
            .past_proposals, .crafter, .spend_info {
                display: none;
            }
            .select_npub, .output_addy, .output_amt {
                display: inline-block;
                width: calc( 100% - 2.5rem );
                margin-bottom: 1rem;
                margin-right: .5rem;
            }
            .output_addy, .output_amt {
                width: calc( 50% - 1.5rem );
            }
            .proposal_div {
                margin-bottom: 1rem;
                word-wrap: break-word;
            }
            .fee_parent p {
                margin-bottom: 0px;
            }
            .proposed_output, .proposed_amt {
                width: calc( 50% - .5rem );
                background-color: #bbbbbb;
                margin-bottom: 0px;
            }
            .plus_button, .minus_button, .output_plus_button {
                display: inline-block;
                border: 1px solid grey;
                padding: 0px 5px;
                cursor: pointer;
                width: 2rem;
                text-align: center;
                vertical-align: top;
                height: 1.8rem;
                line-height: 1.8rem;
            }
            .minus_button, .crafter, .approve_or_deny {
                display: none;
                margin-bottom: 1rem;
            }
            .profile {
                display: inline-block;
                vertical-align: middle;
                width: 100%;
                max-width: 10rem;
                margin: 1rem 0.5rem;
            }
            .profile_wrapper {
                width: 100%;
                display: none;
                background-color: white;
                padding: 1rem;
                border-radius: 1rem;
                text-align: center;
                border: 1px solid black;
            }
            .profile .pic {
                width: 100%;
                max-width: 8rem;
                background-size: cover;
                background-position: center center;
                margin: auto;
                margin-bottom: 1rem;
            }
            .nostr_profiles {
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
            }
            .past_proposals {
                margin-bottom: 1rem;
            }
            .fee_warning {
                display: none;
                border: 2px solid red;
                padding: 1rem;
                background-color: pink;
            }
            .balance {
                word-break: break-all;
            }
            .qr_div {
                border: 1px solid black;
                padding: 1rem;
                border-radius: 1rem;
                text-align: center;
                max-width: 22rem;
                margin: auto;
                margin-top: 1rem;
                background-color: white;
            }
            .qr_code {
                width: 100%;
                max-width: 15rem;
            }
            .menu {
                background-color: pink;
                text-align: center;
            }
            .menu .menu_items .menu_internal div {
                display: inline-block;
                text-align: center;
                padding: .5rem;
                margin: .5rem;
                border: 1px solid black;
                font-size: 80%;
                cursor: pointer;
            }
            .menu .menu_items .menu_internal span {
                font-size: 80%;
            }
            .will_spend_parent {
                display: flex;
                align-items: center;
            }
            .will_spend {
                width: auto;
                margin-right: .5rem;
            }
            .statements .denials_needed, .statements .num_of_respondents {
                display: none;
            }
            .computed_proposal_info {
                margin-top: 1rem;
            }
            .black-bg {
                display: none;
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
                background-color: black;
                opacity: .5;
                width: 100vw;
                height: 100vh;
            }
            .modal {
                display: none;
                position: fixed;
                box-sizing: border-box;
                top: 50%;
                left: 50%;
                transform: translate(-50%,-50%);
                width: 90%;
                max-width: 560px;
                background-color: white;
                border-radius: 1rem;
                padding: 20px;
                color: black;
                text-align: center;
                word-wrap: break-word;
            }
            .modal * {
                color: black;
            }
            .proposal_name_and_author {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .proposal_author {
                display: flex;
                align-items: center;
                background-color: pink;
                border-radius: 2rem;
                padding: 0.5rem;
                border: 1px solid black;
            }
            .proposal_author_nym {
                margin-left: 0.5rem;
            }
            .proposal_author_pic {
                width: 2rem;
                height: 2rem;
                border-radius: 50%;
                background-size: cover;
                background-position: 50% 50%;
                background-repeat: no-repeat;
            }
            .voters_for, .voters_against {
                margin-top: 1rem;
            }
            @media screen and (max-width: 600px) {
                .output_addy, .proposed_output, .proposed_amt {
                    width: 100%;
                }
                .output_amt {
                    width: calc( 100% - 2.5rem );
                }
                .menu {
                    cursor: pointer;
                }
                .menu::before {
                    content: "☰";
                }
                .menu_internal {
                    display: none;
                    padding-bottom: .5rem;
                }
                .menu .menu_items .menu_internal div {
                    display: block;
                }
                .profile {
                    width: calc( 50% - 1rem );
                    max-width: none;
                }
                .proposed_output {
                    margin-bottom: 1rem;
                }
                .proposal_author {
                    width: 100%;
                }
                .proposal_name_and_author {
                    flex-direction: column-reverse;
                }
                .proposal_name_div {
                    width: 100%;
                }
            }
        </style>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys();
            var $_GET = {}
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
        </script>
        <script>
            //file:///home/supertestnet/bitpac_new/index.html?multisig=2f2bcfac3d65b38566e1bebb4124b01b8b8c260c14d63134462ebbb9291d99d4

            //nsec1k8u42lsxlr39k5kffmk735y4w9d0c49rmagch8qkgaeh507f85asjvk327
            //npub1km59cyv30zum7u7chqr46apuruetp4meh7fslsyrg8v0l38acuesvxjt5w
            
            //nsec1av6xezay8zsn06f8zma04ydsqp73ql9y2q9r2fmyrul37d66qluq3s44l3
            //npub1xfjngvj46d9x4w7np6jhsqhxj045vmjc66dqwul3rfhvjmyjxg3s8q7903

            //nsec1ae63rxq0rm43dx7dzpttprkz3zz9u8kw2w83w9pzw6dm5ue8hvlqrv94mj
            //npub1xalptdcq724w46r6y5wcrgp7ajkasvax6y7dg0tz5z8d0s070pzqjppuqx
            var cashu_enabled = false;
            if ( !window.location.href.includes( "index.htm" ) ) {
                var url = "https://" + window.location.hostname + "/bitpac/onboard.html";
                if ( $_GET[ "network" ] ) url += "?network=" + $_GET[ "network" ];
                window.location.href = url;
            }
        </script>
        <script>
            var mempoolnet = "mainnet"; //the full word: mainnet | testnet (works for signet too) | regtest
            var mempoolNetwork = ""; //mainnet: "" | signet: "signet/"
            if ( $_GET[ "network" ] == "testnet" ) {
                mempoolNetwork = "testnet/";
                mempoolnet = "testnet";
            }
            if ( $_GET[ "network" ] == "signet" ) {
                mempoolNetwork = "signet/";
                mempoolnet = "testnet"; //this one is identical for testnet and signet
            }
            if ( $_GET[ "network" ] == "mainnet" ) {
                mempoolNetwork = "";
                mempoolnet = "mainnet";
            }
            if ( $_GET[ "network" ] == "regtest" ) {
                mempoolNetwork = "";
                mempoolnet = "regtest";
            }
            sessionStorage.clear();
            var relays = {
                'wss://relay.damus.io': null,
                'wss://nos.lol': null,
                'wss://nostr.impervious.live': null,
            }
            var bad_relays = {
                'wss://relay.damus.io': 0,
                'wss://nos.lol': 0,
                'wss://nostr.impervious.live': 0,
            }
            sessionStorage[ "utxos" ] = "[]";
            var known_proposals = [];
            var getting_info_for = [];
            var threshold = null;
            var dont_broadcast = [];
            var sigs = {}
            var denys = {}
            var members = {}
            var sha256  = bitcoinjs.crypto.sha256;
            var { getSharedSecret, schnorr, utils } = nobleSecp256k1;
            var bytesToHex = ( bytes ) => {return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, "0" ), "" );}
            if ( !$_GET[ "multisig" ] ) {
                var privKey = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                var pubKey = nobleSecp256k1.getPublicKey( privKey, true ).substring( 2 );
            } else {
                var multisig = null;
            }
            function addNpub( element ) {
                if ( $$( '.select_npub' ).length >= 67 ) {
                    showModal( "max number of keys for the multisig is 67" );
                    return;
                }
                if ( element && $$( '.select_npub' ).length < 67 ) {
                    element.previousElementSibling.style.display = "inline-block";
                }
                if ( $( '.plus_button' ) ) {
                    $( '.plus_button' ).remove();
                }
                var input = document.createElement( "input" );
                input.type = "text";
                var identifier = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() );
                input.className = `select_npub npub_${identifier}`;
                input.onchange = (i) => {
                    var npub = i.srcElement.value;
                    var identifier = i.srcElement.classList[ 1 ].substring( 5 );
                    if ( getting_info_for.includes( JSON.stringify( [ npub, identifier ] ) ) ) return;
                    getting_info_for.push( JSON.stringify( [ npub, identifier ] ) );
                    getCounterpartyInfo( npub, identifier );
                }
                input.onkeyup = (i) => {
                    var npub = i.srcElement.value;
                    var identifier = i.srcElement.classList[ 1 ].substring( 5 );
                    if ( getting_info_for.includes( JSON.stringify( [ npub, identifier ] ) ) ) return;
                    getting_info_for.push( JSON.stringify( [ npub, identifier ] ) );
                    getCounterpartyInfo( npub, identifier );
                }
                $( '.select_npubs' ).append( input );
                var minus = document.createElement( "div" );
                minus.className = "minus_button";
                minus.setAttribute( "data-identifier", identifier );
                minus.innerText = "-";
                minus.onclick = function() {
                    this.previousElementSibling.remove();
                    this.remove();
                    $( `.profile_${this.getAttribute( "data-identifier" )}` ).remove();
                    $( '.multisig_num' ).innerText = $$( '.select_npub' ).length;
                    if ( Number( $( '.select_threshold' ).value ) > $$( '.select_npub' ).length ) $( '.select_threshold' ).value = $$( '.select_npub' ).length;
                    $( '.threshold_num' ).innerText = $( '.select_threshold' ).value;
                }
                $( '.select_npubs' ).append( minus );
                var plus = document.createElement( "div" );
                plus.className = "plus_button";
                plus.innerText = "+";
                plus.onclick = function() {addNpub( this );}
                $( '.select_npubs' ).append( plus );
                var profile = document.createElement( "div" );
                profile.className = `profile profile_${identifier}`;
                profile.innerHTML = `
                    <div class="profile_wrapper"><div class="pic"></div><div class="nym" style="color: black; word-wrap: break-word;"></div></div>
                `;
                $( '.nostr_profiles' ).append( profile );
                $( '.multisig_num' ).innerText = $$( '.select_npub' ).length;
                if ( Number( $( '.select_threshold' ).value ) > $$( '.select_npub' ).length ) $( '.select_threshold' ).value = $$( '.select_npub' ).length;
                $( '.threshold_num' ).innerText = $( '.select_threshold' ).value;
            }
            async function getCounterpartyInfo( npub, identifier ) {
                var div_to_get = `.profile_${identifier}`;
                if ( !npub ) {
                    npub = $( div_to_get ).getAttribute( "data-npub" );
                    $( div_to_get ).innerHTML = `
                        <div class="profile_wrapper" style="display: none;"><div class="pic"></div><div class="nym" style="color: black; word-wrap: break-word;"></div></div>
                    `;
                    getting_info_for.splice( getting_info_for.indexOf( JSON.stringify( [ npub, identifier ] ) ), 1 );
                    return;
                }
                sessionStorage[ identifier ] = npub;
                sessionStorage[ "identifier" ] = identifier;
                sessionStorage[ "npub" ] = npub;
                $$( '.profile' ).forEach( item => {
                    setTimeout( () => {
                        var innerText = item.firstElementChild.getElementsByClassName( "nym" )[ 0 ].innerText;
                        if ( !innerText || innerText === "undefined" ) item.firstElementChild.getElementsByClassName( "nym" )[ 0 ].innerText = "Profile not found";
                        item.firstElementChild.style.display = "inline-block";
                    }, 3000 );
                });
                var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                    var myrelay = Object.keys( relays )[ i ];
                    await waitForOneRelay( true );
                    if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                    var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).toString( "hex" ).substring( 0, 24 );
                    var filter = { "kinds": [ 0 ], "authors": [ pubkeyFromNpub( npub ) ], limit: 1 }
                    var subscription = [ "REQ", subId, filter ];
                    relays[ myrelay ].addEventListener( "message", handleMessage );
                    relays[ myrelay ].send( JSON.stringify( subscription ) );
                    await waitSomeSeconds( 2 );
                    relays[ myrelay ].close();
                }
            }
            function pubkeyFromNpub(npub) {
                return Buffer.from(bech32.bech32.fromWords(bech32.bech32.decode(npub).words)).toString("hex");
            }
            function pubkeyToNpub(hex) {
                return bech32.bech32.encode("npub", bech32.bech32.toWords(Buffer.from(hex, "hex")));
            }
            function privkeyFromNsec( nsec ) {
                return Buffer.from( bech32.bech32.fromWords( bech32.bech32.decode( nsec ).words ) ).toString( "hex" );
            }
            var isValidNpub = (npub) => {
                try {
                    var pubkey = pubkeyFromNpub( npub );
                    return true;
                } catch( e ) {
                    return;
                }
            }
            var handleMessage = async ( message ) => {
                var [ type, subId, event ] = JSON.parse( message.data );
                var { kind, content } = event || {}
                if ( !event || event === true ) return;
                if ( kind === 0 ) {
                    if ( $_GET[ "multisig" ] ) {
                        await getNote( "ready_to_load_profiles" );
                        var i; for ( i=0; i<67; i++ ) {
                            if ( i > $$( ".profile" ).length - 1 ) continue;
                            var div_to_get = `.profile_${event.pubkey}_${i}`;
                            if ( !$( div_to_get ) ) continue;
                            $( '.loading_profiles' ).style.display = "none";
                            $( div_to_get ).setAttribute( "data-npub", pubkeyToNpub( event.pubkey ) );
                            if ( !JSON.parse( content )[ "name" ] && !JSON.parse( content )[ "picture" ] ) continue;
                            $( div_to_get ).firstElementChild.style.display = "inline-block";
                            var name = JSON.parse( content )[ "display_name" ];
                            if ( !name ) name = JSON.parse( content )[ "name" ];
                            $( `${div_to_get} .nym` ).innerText = name;
                            $( `${div_to_get} .pic` ).style.backgroundImage = `url( ${JSON.parse( content )[ "picture" ]} )`;
                            members[ event.pubkey ] = {
                                nym: name,
                                pic: JSON.parse( content )[ "picture" ],
                            }
                        }
                    } else {
                        var div_to_get = `.profile_${sessionStorage[ "identifier" ]}`;
                        $( div_to_get ).setAttribute( "data-npub", pubkeyToNpub( event.pubkey ) );
                        if ( !JSON.parse( content )[ "name" ] && !JSON.parse( content )[ "picture" ] ) return;
                        $( div_to_get ).firstElementChild.style.display = "inline-block";
                        $( `${div_to_get} .nym` ).innerText = JSON.parse( content )[ "name" ];
                        $( `${div_to_get} .pic` ).style.backgroundImage = `url( ${JSON.parse( content )[ "picture" ]} )`;
                    }
                }
                if ( kind === 2858 ) {
                    if ( multisig ) return;
                    var bitpac = JSON.parse( content );
                    bitpac_name = bitpac[ 0 ];
                    multisig = bitpac[ 1 ];
                    var temp_multisig = [...multisig];
                    threshold = temp_multisig[ 0 ];
                    temp_multisig.splice( 0, 1 );
                    var script = [0];
                    temp_multisig.forEach( item => {
                        script.push( item, "OP_CHECKSIGADD" );
                    });
                    var pubkey = "ab".repeat( 32 );
                    script.push( threshold, "OP_EQUAL" );
                    var sbytes = tapscript.Script.encode( script );
                    var tapleaf = tapscript.Tap.tree.getLeaf( sbytes );
                    var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { target: tapleaf });
                    var multisig_address = tapscript.Address.p2tr.fromPubKey( tpubkey, mempoolnet );
                    if ( cashu_enabled ) {
                        var amount_to_send = prompt( 'enter an amount you want to send' );
                        amount_to_send = Number( amount_to_send );
                        if ( !amount_to_send ) return;
                        var keysets = await getData( `https://testnut.cashu.space/v1/keysets` );
                        keysets = JSON.parse( keysets )[ "keysets" ];
                        var keyset;
                        keysets.every( item => {if ( isValidHex( item.id ) && item.active ) {keyset = item.id;return;} return true;});
                        var mint_pubkeys = await getData( `https://testnut.cashu.space/v1/keys/${keyset}` );
                        mint_pubkeys = JSON.parse( mint_pubkeys )[ "keysets" ][ 0 ][ "keys" ];
                        var ecash_amounts = decomposeAmount( amount_to_send );
                        Object.keys( mint_pubkeys ).forEach( item => {if ( !ecash_amounts.includes( Number( item ) ) ) delete mint_pubkeys[ item ] });
                        var ecash_outputs = await getEcash( temp_multisig, ecash_amounts, keyset );
                        var datum = JSON.stringify({"amount": amount_to_send, "unit": "sat"});
                        var invoice_data = await postData( `https://testnut.cashu.space/v1/mint/quote/bolt11`, datum, "application/json" );
                        invoice_data = JSON.parse( invoice_data );
                        var quote_id = invoice_data[ "quote" ];
                        var invoice = invoice_data[ "request" ];
                        var is_paid_info = await getData( `https://testnut.cashu.space/v1/mint/quote/bolt11/${quote_id}` );
                        is_paid = JSON.parse( is_paid_info )[ "paid" ];
                        if ( !is_paid ) return console.log( "is paid, right?", is_paid );
                        var stripped_ecash_outputs = [];
                        Object.keys( ecash_outputs ).forEach( ( item, index ) => {
                            stripped_ecash_outputs.push({
                                "amount": ecash_outputs[ item ][ "amount" ],
                                "id": ecash_outputs[ item ][ "id" ],
                                "B_": ecash_outputs[ item ][ "B_" ],
                            });
                        });
                        var sig_request = {
                            "quote": quote_id,
                            "outputs": stripped_ecash_outputs,
                        }
                        var blinded_sigs = await postData( `https://testnut.cashu.space/v1/mint/bolt11`, JSON.stringify( sig_request ), "application/json" );
                        blinded_sigs = JSON.parse( blinded_sigs );
                        var sig_pairs = [];
                        var inputs = [];
                        blinded_sigs[ "signatures" ].forEach( item => {
                            var blinded_sig = item[ "C_" ];
                            var mint_pubkey = mint_pubkeys[ String( item[ "amount" ] ) ];
                            var mint_pubkey_point = nobleSecp256k1.Point.fromCompressedHex( hexToBytes( mint_pubkey ) );
                            var C_ = nobleSecp256k1.Point.fromCompressedHex( hexToBytes( blinded_sig ) );
                            var message = ecash_outputs[ `num_${item[ "amount" ]}` ][ "message" ];
                            var {C, secret} = message.unblindSignature( C_, mint_pubkey_point );
                            var compressed_C = getCompressedPubkeyHexFromUncompressedPubkeyHex( blindSigJS.ecPointToHex( C ) );
                            sig_pairs.push({
                                amount: item[ "amount" ],
                                blinded_sig,
                                mint_pubkey,
                                unblinded_sig: compressed_C,
                            });
                            var input = {
                                id: keyset,
                                amount: item[ "amount" ],
                                secret: ecash_outputs[ `num_${item[ "amount" ]}` ][ "secret_for_message" ],
                                C: compressed_C,
                            }
                            inputs.push( input );
                        });
                        console.log( "sig pairs" );
                        console.log( sig_pairs );
                        console.log( "inputs" );
                        console.log( inputs );
                        var amount_i_want = amount_to_send;
                        var eleventh_secret_for_message = bytesToHex( blindSigJS.getRand( 32 ) );
                        var eleventh_message = new blindSigJS.bsjMsg();
                        var eleventh_B_ = await eleventh_message.createBlindedMessageFromString( eleventh_secret_for_message );
                        var eleventh_output_B_hex = blindSigJS.ecPointToHex( eleventh_B_ );
                        var msghash = sha256( hexToBytes( eleventh_output_B_hex ) );
                        var tenth_privkey_for_message = prompt( `Enter one of the nsecs` );
                        tenth_privkey_for_message = privkeyFromNsec( tenth_privkey_for_message );
                        var eleventh_output_sig = await nobleSecp256k1.schnorr.sign( msghash, tenth_privkey_for_message );
                        eleventh_output_sig = bytesToHex( eleventh_output_sig );
                        var tenth_privkey_2_for_message = prompt( `Enter another one of the nsecs` );
                        tenth_privkey_2_for_message = privkeyFromNsec( tenth_privkey_2_for_message );
                        var eleventh_output_sig_2 = await nobleSecp256k1.schnorr.sign( msghash, tenth_privkey_2_for_message );
                        eleventh_output_sig_2 = bytesToHex( eleventh_output_sig_2 );
                        var eleventh_output = {
                            "amount": amount_i_want,
                            "id": keyset,
                            "B_": eleventh_output_B_hex,
                            "witness": JSON.stringify({
                                "signatures":
                                [
                                    eleventh_output_sig,
                                    eleventh_output_sig_2
                                ]
                            })
                        }
                        //TODO: make getEcashInputs automatically fail if the amount I want
                        //to send is less than the amount I have, else add my ecash inputs
                        //together to obtain an amount *greater than or equal to* the amount
                        //I want to send, then -- if the amount is greater than the amount I
                        //want to send -- use swaps to get an amount that is equal, then
                        //return the resulting set of inputs
                        /*
                            regarding "use swaps to get an amount that is equal," here is a
                            procedure for that.
                            Suppose I have 14 as 1, 1, 2, 2, 8, and I want to send 13 total,
                            which decomposes to 1, 4, 8. My first step is to turn my
                            amounts into the largest denominations available. I have a
                            function called recomposeAmount which tells me what amounts I
                            need to get to, so, for example, if I pass in [1, 1, 2, 2, 8 ]
                            it will tell me I need to get to [2, 4, 8]. From there I can
                            compare the biggest number in "what I need to get to" with the
                            biggest number in "what I currently have." If they are the same,
                            I can ignore that number. If "what I need to get to" is larger
                            than "what I currently have" then I should, starting with my
                            smallest input, continually add them together til they are
                            greater than or equal to the amount I need to get to, then, if
                            they're greater, turn the difference into powers of two, then
                            do a swap that converts the resuting set of inputs into the
                            number I need to get to and some change. Then I can ignore the
                            biggest number and repeat with the next biggest number. Loop
                            until I have 8, 4, 2.
                            Once I have 8, 4, 2 I need to compare the amounts I want to
                            send with the amounts I have. Again, I start by comparing the
                            top numbers in each set. If they are the same, I can ignore that
                            number. If "what I have" is larger than "what I need to get to"
                            then, starting with the largest remaining input in "what I have"
                            (after ignoring the numbers that were ignored previously), I
                            should halve it and duplicate the two halves (thus, for example,
                            turning 8 into 4, 4) and check if the first half is equal to
                            what I need to get to. If not, repeat with the first half til one
                            of its "children" is the same size as what I need to get to.
                            Then take all of its parents and siblings and add them to the
                            set of "what I have" and add the matching number to the set of
                            "what I will spend" and repeat. Eventually this should get me
                            a set of proofs that exactly equal the amount I want to send,
                            and the remaining change should just be available for whatever
                            I want to do next.
                            
                            (async () => {
                                var my_holdings = [{amount: 2}, {amount: 2}, {amount: 2}, {amount: 2}, {amount: 4}, {amount: 4}, {amount: 8}, {amount: 8}, {amount: 8}, {amount: 2}, {amount: 4}, {amount: 64}];
                                my_holdings = split_array( my_holdings );
                                var keysets = await getData( `https://testnut.cashu.space/v1/keysets` );
                                keysets = JSON.parse( keysets )[ "keysets" ];
                                var keyset;
                                keysets.every( item => {if ( isValidHex( item.id ) && item.active ) {keyset = item.id;return;} return true;});
                                var temp_multisig = [...multisig];
                                temp_multisig.splice( 0, 1 );
                                var inputs_i_have_obj = await getEcash( temp_multisig, [2, 4, 64], keyset );
                                var inputs_i_have = [];
                                Object.keys( inputs_i_have_obj ).forEach( item => inputs_i_have.push( inputs_i_have_obj[ item ] ) );
                                inputs_i_have.forEach( ( item, index ) => {
                                    inputs_i_have[ index ][ "message" ][ "B_" ] = blindSigJS.ecPointToHex( item[ "message" ][ "B_" ] );
                                    inputs_i_have[ index ][ "message" ][ "Y" ] = blindSigJS.ecPointToHex( item[ "message" ][ "Y" ] );
                                    inputs_i_have[ index ][ "message" ][ "rG" ] = blindSigJS.ecPointToHex( item[ "message" ][ "rG" ] );
                                    inputs_i_have[ index ][ "message" ][ "r" ] = blindSigJS.bigIntToHex( item[ "message" ][ "r" ] );
                                });
                                var array_of_subarrays = [ JSON.parse( JSON.stringify( inputs_i_have ) ) ];
                                var amts_to_recompose = [];
                                inputs_i_have.forEach( input => amts_to_recompose.push( input.amount ) );
                                var amts_i_need = recomposeAmount( amts_to_recompose );
                                var inputs_i_need = [];
                                amts_i_need.forEach( item => inputs_i_need.push({amount: item}));
                                inputs_i_have.sort( ( a, b ) => b.amount - a.amount );
                                inputs_i_need.sort( ( a, b ) => b.amount - a.amount );
                                // console.log( "inputs_i_need:", JSON.parse( JSON.stringify( inputs_i_need ) ) );
                                var inputs_to_use = [];
                                var i; for ( i=0; i<inputs_i_have.length; i++ ) {
                                    if ( inputs_i_have[ i ].amount == inputs_i_need[ i ].amount ) {
                                        inputs_to_use.push( inputs_i_have[ i ] );
                                        inputs_i_have.splice( 0, 1 );
                                        inputs_i_need.splice( 0, 1 );
                                        i = i - 1;
                                    } else {
                                        var amt_i_need = inputs_i_need[ 0 ].amount;
                                        var sum = 0;
                                        var inputs_to_swap = [];
                                        var other_ordered = JSON.parse( JSON.stringify( inputs_i_have ) );
                                        other_ordered.reverse();
                                        var change_needed = [];
                                        //this loop starts from the smallest outputs I have and keeps on
                                        //adding more and more of them to an array til I have an amount
                                        //of outputs whose sum is equal to or greater than the amount I
                                        //need in order to create this expenditure
                                        var j; for ( j=0; j<other_ordered.length; j++ ) {
                                            var index = j;
                                            var item = other_ordered[ j ];
                                            sum = sum + item.amount;
                                            inputs_to_swap.push( item );
                                            inputs_i_have.splice( inputs_i_have.length - 1 - index, 1 );
                                            other_ordered.splice( index, 1 );
                                            j = j - 1;
                                            if ( sum == amt_i_need ) break;
                                            if ( sum > amt_i_need ) change_needed = decomposeAmount( sum - amt_i_need );
                                            if ( sum > amt_i_need ) break;
                                        }
                                        //TODO: fix the problem which I outline in the following lines: I must get
                                        //some change outputs sometimes, and when I run the getEcash function, it
                                        //will not actually get them for me -- it just prepares outputs that I
                                        //can request from the mint and pay for with other ecash or via lightning.
                                        //But I immediately add those as-yet-unpaid-for inputs to other_ordered
                                        //and use them to get the amounts I need. Somehow I need to mark these
                                        //outputs as "virtual" and keep track of what children they pay for (if
                                        //any) and ensure the multisig votes to create them *before* using them
                                        //to create more ecash.
                                        //I think I can do this by creating an array of subarrays. The first sub-
                                        //array should say what inputs I will use, so that if we get more
                                        //contributions before everyone votes, it won't affect much. The second
                                        //subarray should specify the "second state" of other_ordered and
                                        //everyone should vote to create that one first. The third subarray should
                                        //specify the "third state" of other_ordered and so on.
                                        var change_inputs_obj = await getEcash( temp_multisig, change_needed, keyset );
                                        var change_inputs = [];
                                        Object.keys( change_inputs_obj ).forEach( item => change_inputs.push( change_inputs_obj[ item ] ) );
                                        //I am about to swap inputs_to_swap for an output with a value
                                        //equal to amt_i_need, but first I need to add change_inputs back
                                        //into other_ordered and inputs_i_have so I can use them to make
                                        //more change if needed
                                        other_ordered.push( ...change_inputs );
                                        other_ordered.sort( ( a, b ) => a.amount - b.amount );
                                        inputs_i_have.push( ...change_inputs );
                                        inputs_i_have.sort( ( a, b ) => b.amount - a.amount );
                                        //TODO: do the swap here before proceeding, trading the inputs_to_swap
                                        //for an input whose value is equal to amt_i_need.
                                        var swapped_inputs_obj = await getEcash( temp_multisig, [amt_i_need], keyset );
                                        var swapped_inputs = [];
                                        Object.keys( swapped_inputs_obj ).forEach( item => swapped_inputs.push( swapped_inputs_obj[ item ] ) );
                                        inputs_to_use.push( ...swapped_inputs );
                                        array_of_subarrays.push( JSON.parse( JSON.stringify( [ inputs_i_have, inputs_to_use ] ) ) );
                                        inputs_i_need.splice( 0, 1 );
                                        i = i - 1;
                                    }
                                }
                                console.log( "array_of_subarrays" );
                                console.log( array_of_subarrays );
                                inputs_i_have.push( ...inputs_to_use );
                                inputs_i_have.sort( ( a, b ) => b.amount - a.amount );
                                var amount_i_want_to_send = 13;
                                var amts_to_send = decomposeAmount( amount_i_want_to_send );
                                var inputs_i_need = [];
                                amts_to_send.forEach( item => inputs_i_need.push({amount: item}) );
                                console.log( "inputs i need" );
                                console.log( JSON.parse( JSON.stringify( inputs_i_need ) ) );
                                inputs_to_use = [];
                                var i; for ( i=0; i<inputs_i_have.length; i++ ) {
                                    if ( inputs_i_have[ i ].amount == inputs_i_need[ i ].amount ) {
                                        inputs_to_use.push( inputs_i_have[ i ] );
                                        inputs_i_have.splice( 0, 1 );
                                        inputs_i_need.splice( 0, 1 );
                                        i = i - 1;
                                    } else {
                                        var [ match, siblings_and_parents ] = split_and_repeat( inputs_i_have[ i ], inputs_i_need[ i ].amount, [] );
                                        inputs_to_use.push( match );
                                        inputs_i_need.splice( 0, 1 );
                                        inputs_i_have.splice( 0, 1 );
                                        inputs_i_have.splice( 0, 0, ...siblings_and_parents );
                                        inputs_i_have.sort( ( a, b ) => b.amount - a.amount );
                                        i = i - 1;
                                    }
                                    var sum_of_inputs_to_use = 0;
                                    inputs_to_use.forEach( item => sum_of_inputs_to_use = sum_of_inputs_to_use + item.amount );
                                    if ( sum_of_inputs_to_use == amount_i_want_to_send ) break;
                                }
                                console.log( 2, "inputs_to_use" );
                                console.log( JSON.parse( JSON.stringify( inputs_to_use ) ) );
                                console.log( 3, "inputs_i_have" );
                                console.log( JSON.parse( JSON.stringify( inputs_i_have ) ) );
                            })();
                        */
                        var new_inputs = getEcashInputs( amount_i_want, inputs );
                        var i; for ( i=0; i<new_inputs.length; i++ ) {
                            var input = new_inputs[ i ];
                            var msghash = sha256( input[ "secret" ] );
                            var sig_1 = await nobleSecp256k1.schnorr.sign( msghash, tenth_privkey_for_message );
                            sig_1 = bytesToHex( sig_1 );
                            var sig_2 = await nobleSecp256k1.schnorr.sign( msghash, tenth_privkey_2_for_message );
                            sig_2 = bytesToHex( sig_2 );
                            input.witness = JSON.stringify({
                                "signatures":
                                [
                                    sig_1,
                                    sig_2,
                                ]
                            });
                        }
                        var eleventh_swap_data = {
                            "inputs": new_inputs,
                            "outputs": [eleventh_output],
                        }
                        console.log( eleventh_swap_data );
                        var eleventh_blinded_sigs = await postData( `https://testnut.cashu.space/v1/swap`, JSON.stringify( eleventh_swap_data ), "application/json" );
                        var eleventh_blinded_sig = JSON.parse( eleventh_blinded_sigs )[ "signatures" ][ 0 ][ "C_" ];
                        console.log( "eleventh_blinded_sig:", eleventh_blinded_sig );
                        var eleventh_C_ = nobleSecp256k1.Point.fromCompressedHex( hexToBytes( eleventh_blinded_sig ) );
                        var mint_pubkey = mint_pubkeys[ String( amount_i_want ) ];
                        var mint_pubkey_point = nobleSecp256k1.Point.fromCompressedHex( hexToBytes( mint_pubkey ) );
                        var {C, secret} = eleventh_message.unblindSignature( eleventh_C_, mint_pubkey_point );
                        var eleventh_C = C;
                        var eleventh_secret = secret;
                        var eleventh_compressed_C = getCompressedPubkeyHexFromUncompressedPubkeyHex( blindSigJS.ecPointToHex( eleventh_C ) );
                        var eleventh_input = {
                            id: keyset,
                            amount: amount_i_want,
                            secret: eleventh_secret_for_message,
                            C: eleventh_compressed_C,
                        }

                        //swap a twelfth time

                        var twelfth_secret_for_message = bytesToHex( blindSigJS.getRand( 32 ) );
                        var twelfth_message = new blindSigJS.bsjMsg();
                        var twelfth_B_ = await twelfth_message.createBlindedMessageFromString( twelfth_secret_for_message );
                        var twelfth_output_B_hex = blindSigJS.ecPointToHex( twelfth_B_ );
                        var twelfth_output = {
                            "amount": amount_i_want,
                            "id": keyset,
                            "B_": twelfth_output_B_hex,
                        }
                        var twelfth_swap_data = {
                            "inputs": [eleventh_input],
                            "outputs": [twelfth_output],
                        }
                        var twelfth_blinded_sigs = await postData( `https://testnut.cashu.space/v1/swap`, JSON.stringify( twelfth_swap_data ), "application/json" );
                        var twelfth_blinded_sig = JSON.parse( twelfth_blinded_sigs )[ "signatures" ][ 0 ][ "C_" ];
                        console.log( "twelfth_blinded_sig:", twelfth_blinded_sig );
                        var twelfth_C_ = nobleSecp256k1.Point.fromCompressedHex( hexToBytes( twelfth_blinded_sig ) );
                        var {C, secret} = twelfth_message.unblindSignature( twelfth_C_, mint_pubkey_point );
                        var twelfth_C = C;
                        var twelfth_secret = secret;
                        var twelfth_compressed_C = getCompressedPubkeyHexFromUncompressedPubkeyHex( blindSigJS.ecPointToHex( twelfth_C ) );
                        var twelfth_input = {
                            id: keyset,
                            amount: amount_i_want,
                            secret: twelfth_secret_for_message,
                            C: twelfth_compressed_C,
                        }
                        console.log( "twelfth_input:", twelfth_input );
                    }
                    var url = "bitcoin:" + multisig_address;
                    var a = document.createElement( "a" );
                    a.href = url;
                    a.target = "_blank";
                    a.append( createQR( url ) );
                    var div = document.createElement( "div" );
                    div.append( a );
                    var div_html = div.innerHTML;
                    var html = `
                        <div class="menu" onclick='if ( window.innerWidth > 600 ) return; if ( this.getElementsByClassName( "menu_internal" )[ 0 ].style.display != "block" ) {this.getElementsByClassName( "menu_internal" )[ 0 ].style.display = "block"} else {this.getElementsByClassName( "menu_internal" )[ 0 ].style.display = "none"}'>
                            <div class="menu_items">
                                <div class="menu_internal">
                                    <div class="menu_members">Members</div>
                                    <div class="menu_balance">Treasury</div>
                                    <div class="menu_statements">Statements</div>
                                    <div class="menu_cprops">Current proposals [<span class="cprops">0</span>]</div>
                                    <div class="menu_pprops">Past proposals [<span class="pprops">0</span>]</div>
                                    <div class="menu_login_or_create">Login</div>
                                    <div class="menu_easy_sign_in hidden">Easy sign in</div>
                                </div>
                            </div>
                        </div>
                        <div class="members">
                            <h2>Members</h2>
                            Bitpac name: ${bitpac_name}<br>
                            Policy: ${threshold} out of ${temp_multisig.length}
                        <div class="nostr_profiles">
                            <p class="loading_profiles">Loading<span class="dots">.</span></p>
                        </div>
                        </div>
                        <div class="balance">
                            <h2>Treasury</h2>
                            Balance (usd): <span class="bitpac_balance">loading<span class="dots">.</span></span><br>
                            Balance (sats): <span class="bitpac_balance_sats">loading<span class="dots">.</span></span><br>
                            <div class="qr_div">
                                ${div_html}
                                <div class="addy">${multisig_address}</div><br>
                            </div>
                        </div>
                        <div class="statements">
                            <h2>Statements</h2>
                            <p class="no_statements">Loading<span class="dots">.</span></p>
                        </div>
                        <div class="current_proposals">
                            <h2>Current proposals</h2>
                            <p class="none_currently">Loading<span class="dots">.</span></p>
                        </div>
                        <div class="past_proposals">
                            <h2>Past proposals</h2>
                            <p class="no_past_proposals">Loading<span class="dots">.</span></p>
                        </div>
                        <div class="crafter">
                            <h2>Craft a proposal</h2>
                            <p>Briefly name or describe your proposal</p>
                            <p><input class="proposal_desc"></p>
                            <p>Propose a statement (optional)</p>
                            <p><textarea class="statement"></textarea></p>
                            <p class="will_spend_parent" onclick='if ( $( ".spend_info" ).style.display != "block" ) {$( ".spend_info" ).style.display = "block";$( ".will_spend" ).checked = true;} else {$( ".spend_info" ).style.display = "none";$( ".will_spend" ).checked = false;}'>
                                <input type="checkbox" class="will_spend" name="will_spend">
                                <label for="will_spend">I want to spend some money</label>
                            </p>
                            <div class="spend_info">
                                <p>How do you want to spend the money?</p>
                                Balance (usd): <span class="bitpac_balance">loading<span class="dots">.</span></span><br>
                                Balance (sats): <span class="bitpac_balance_sats">loading<span class="dots">.</span></span>
                                <br><br>
                                <div class="add_outputs"></div>
                            </div>
                            <p><button class="craft_proposal">Submit</button></p>
                        </div>
                    `;
                    sessionStorage[ "loop_num" ] = "0";
                    var div = document.createElement( "div" );
                    div.innerHTML = html;
                    $( '.loading' ).remove();
                    $( '.multisig_viewer' ).append( div );
                    $( '.menu_members' ).onclick = () => {
                        showPage( "members" );
                    }
                    $( '.menu_balance' ).onclick = () => {
                        showPage( "balance" );
                    }
                    $( '.menu_statements' ).onclick = () => {
                        if ( $( '.statements .proposal_div' ) ) $( '.no_statements' ).style.display = "none"; else $( '.no_statements' ).style.display = "block";
                        showPage( "statements" );
                    }
                    $( '.menu_cprops' ).onclick = () => {
                        if ( $( '.current_proposals .proposal_div' ) ) $( '.none_currently' ).style.display = "none"; else $( '.none_currently' ).style.display = "block";
                        showPage( "current_proposals" );
                    }
                    $( '.menu_pprops' ).onclick = () => {
                        if ( $( '.past_proposals .proposal_div' ) ) $( '.no_past_proposals' ).style.display = "none"; else $( '.no_past_proposals' ).style.display = "block";
                        showPage( "past_proposals" );
                    }
                    $( '.menu_easy_sign_in' ).onclick = () => {
                        if ( $_GET[ "easy_sign_in" ] ) {
                            $( '.instructions_for_easy_sign_in' ).classList.add( "hidden" );
                            $( '.alternative_instructions_for_easy_sign_in' ).classList.remove( "hidden" );
                        }
                        showPage( "easy_sign_in" );
                    }
                    $( '.menu_login_or_create' ).onclick = async () => {
                        if ( $_GET[ "easy_sign_in" ] && !$( '.menu_login_or_create' ).innerText.includes( "Craft" ) ) {
                            sessionStorage.removeItem( "easy_sign_in_username" );
                            sessionStorage.removeItem( "easy_sign_in_password" );
                            showModal( `
                                <p style="font-weight: bold">Username</p>
                                <p><input style="width: 90%;" class="easy_sign_in_username"></p>
                                <p style="font-weight: bold">Password</p>
                                <p><input style="width: 90%;" type="password" class="easy_sign_in_password"></p>
                                <p><button class="submit_easy_name_and_pw" onclick="sessionStorage[ 'easy_sign_in_username' ] = $( '.easy_sign_in_username' ).value;sessionStorage[ 'easy_sign_in_password' ] = $( '.easy_sign_in_password' ).value;modalVanish();">Submit</button></p>
                            ` );
                            var username = await getNote( "easy_sign_in_username" );
                            var password = await getNote( "easy_sign_in_password" );
                            sessionStorage.removeItem( "easy_sign_in_username" );
                            sessionStorage.removeItem( "easy_sign_in_password" );
                            var hashable = String( username ) + String( password );
                            console.log( hashable );
                            hashable = hexToBytes( textToHex( hashable ) );
                            var sign_in_privkey = bytesToHex( sha256( hashable ) );
                            var sign_in_pubkey = nobleSecp256k1.getPublicKey( sign_in_privkey, true ).substring( 2 );
                            var bech32_encoded_encrypted_privkey = $_GET[ "easy_sign_in" ];
                            var decoded_encrypted_privkey = hexToText( Buffer.from( bech32.bech32m.fromWords( bech32.bech32m.decode( bech32_encoded_encrypted_privkey, 10000 ).words ) ).toString( "hex" ) );
                            try {
                                var my_decrypted_privkey = decrypt( sign_in_privkey, sign_in_pubkey, decoded_encrypted_privkey );
                            } catch( e ) {
                                console.log( e );
                                var url = window.location.href.substring( 0, window.location.href.indexOf( "&" ) );
                                return showModal( `<p>Your username and password did not work. Try again or visit the following link and sign in with your nsec</p><p><a href="${url}">${url}</a></p>` );
                            }
                            return login_fn( my_decrypted_privkey );
                        }
                        if ( $( '.proposal_desc' ) ) {
                            $( '.proposal_desc' ).value = "";
                            $( '.statement' ).value = "";
                            $$( '.add_outputs .output_addy' ).forEach( item => {
                                item.value = "";
                            });
                            $$( '.add_outputs .output_amt' ).forEach( item => {
                                item.value = "";
                            });
                            $$( '.add_outputs .minus_button' ).forEach( (item, index) => {
                                if ( index != $$( '.add_outputs .minus_button' ).length - 1 ) {
                                    setTimeout( function() {
                                        item.click();
                                    }, index );
                                }
                            });
                            if ( $( '.will_spend' ).checked ) $( '.will_spend_parent' ).click();
                        }
                        showPage( "login_form" );
                    }
                    $( '.craft_proposal' ).onclick = spendCoins;
                    loadProfiles( temp_multisig );
                    var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                        var myrelay = Object.keys( relays )[ i ];
                        await waitForOneRelay( true );
                        if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                        var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).toString( "hex" ).substring( 0, 24 );
                        var filter = { authors: temp_multisig, kinds: [ 0 ], limit: temp_multisig.length }
                        var filter2 = { authors: temp_multisig, kinds: [ 2859 ], "#e": [ $_GET[ "multisig" ] ] }
                        var subscription = [ "REQ", subId, filter, filter2 ];
                        relays[ myrelay ].addEventListener( "message", handleMessage );
                        relays[ myrelay ].send( JSON.stringify( subscription ) );
                        sessionStorage[ "ready_to_load_profiles" ] = true;
                    }
                    if ( !isNaN( $( '.bitpac_balance_sats' ).innerText ) ) $( '.none_currently' ).innerText = "None currently";
                    addOutput();
                }
                if ( kind === 2859 ) {
                    if ( known_proposals.includes( event.id ) ) return;
                    known_proposals.push( event.id );
                    var prop_id = event.id;
                    await waitForBalanceToLoad();
                    var one_month_ago = Math.floor( Date.now() / 1000 ) - ( 60 * 60 * 24 * 30 );
                    var proposal_should_go_in_past_proposals = false;
                    if ( event.created_at - one_month_ago < 0 ) proposal_should_go_in_past_proposals = true;
                    $( '.no_statements' ).innerText = "None yet";
                    $( '.no_past_proposals' ).innerText = "None yet";
                    var proposal = JSON.parse( content );
                    var html = `
                        <div class="proposal_name_and_author">
                            <div class="proposal_name_div"><p class="proposal_name" style="font-weight: bold;"></p></div>
                            <div class="proposal_author">
                                <div class="proposal_author_pic"></div>
                                <div class="proposal_author_nym"></div>
                            </div>
                        </div>
                        <div class="proposal_statement"></div>
                        <div class="expense_info"></div>
                        <div class="computed_proposal_info"></div>
                        <div class="countdown_div"><h2>Proposal expiry</h2><p class="countdown"></p></div>
                        <div class="voters_for hidden"><h2>For</h2></div>
                        <div class="voters_against hidden"><h2>Against</h2></div>
                        <div class="voters_undecided"><h2>Not voted yet</h2></div>
                    `;
                    var div = document.createElement( "div" );
                    div.innerHTML = html;
                    div.className = `proposal_div proposal_${event.id}`;
                    div.style = "border: 1px solid black; border-radius: 1rem; padding: 1rem;"
                    div.getElementsByClassName( "proposal_author_pic" )[ 0 ].style.backgroundImage = `url("${members[ event.pubkey ][ "pic" ]}")`;
                    div.getElementsByClassName( "proposal_author_nym" )[ 0 ].innerText = members[ event.pubkey ][ "nym" ];
                    div.getElementsByClassName( "proposal_name" )[ 0 ].innerText = proposal[ 0 ];
                    if ( proposal[ 3 ] ) {
                        div.getElementsByClassName( "proposal_statement" )[ 0 ].innerText = proposal[ 3 ];
                    }
                    var when_proposed = event.created_at;
                    var seconds_til_disappears = when_proposed - one_month_ago;
                    var friendly_time = convertHMS( seconds_til_disappears );
                    div.getElementsByClassName( "countdown" )[ 0 ].innerText = friendly_time;
                    Object.keys( members ).forEach( item => {
                        var member = members[ item ];
                        var html = div.getElementsByClassName( "voters_undecided" )[ 0 ].innerHTML;
                        html += `
                            <div class="proposal_author undecided_${item}" style="margin: 0.5rem; float: none;">
                                <div class="proposal_author_pic" style="background-image: url( '${member[ "pic" ]}' )"></div>
                                <div class="proposal_author_nym">${member[ "nym" ]}</div>
                            </div>
                        `;
                        div.getElementsByClassName( "voters_undecided" )[ 0 ].innerHTML = html;
                    });
                    if ( !proposal[ 1 ].length && !proposal[ 3 ] ) return;
                    if ( proposal[ 1 ].length && proposal[ 2 ].length ) {
                        var from_amount = Number( $( '.bitpac_balance_sats' ).innerText );
                        //ensure the input(s) exist in our utxo set
                        //otherwise this proposal should go into past proposals
                        var input_utxos_are_ours = true;
                        var utxos = JSON.parse( sessionStorage[ "utxos" ] );
                        var stringified_utxos = [];
                        utxos.forEach( item => {
                            stringified_utxos.push( JSON.stringify( item ) );
                        });
                        proposal[ 1 ].every( item => {
                            var txid = item[ "txid" ];
                            var vout = item[ "vout" ];
                            var amt = item[ "prevout" ][ "value" ];
                            var stringified_input = JSON.stringify( [txid, vout, amt] );
                            if ( !stringified_utxos.includes( stringified_input ) ) {
                                input_utxos_are_ours = false;
                                return;
                            }
                            return true;
                        });
                        if ( !input_utxos_are_ours ) {
                            proposal_should_go_in_past_proposals = true;
                            dont_broadcast.push( event.id );
                        }
                        $( '.none_currently' ).style.display = "none";
                        var has_change = tapscript.Address.fromScriptPubKey( proposal[ 2 ][ proposal[ 2 ].length - 1 ][ "scriptPubKey" ] ) == tapscript.Address.fromScriptPubKey( tapscript.Address.toScriptPubKey( $( '.addy' ).innerText ) ) ? true : false;
                        if ( has_change ) {
                            var change_amount = proposal[ 2 ][ proposal[ 2 ].length - 1 ][ "value" ];
                        } else {
                            var change_amount = 0;
                        }
                        var to_amount = 0;
                        proposal[ 2 ].forEach( ( item, index ) => {
                            if ( has_change && index == proposal[ 2 ].length - 1 ) return;
                            to_amount = to_amount + item.value;
                            var div2 = document.createElement( "div" );
                            div2.innerHTML = `
                                <p><input class="output_addy proposed_output" disabled><input class="output_amt proposed_amt" disabled></p>
                            `;
                            div2.getElementsByClassName( "output_addy" )[ 0 ].value = tapscript.Address.fromScriptPubKey( item.scriptPubKey, mempoolnet );
                            div2.getElementsByClassName( "output_amt" )[ 0 ].value = item.value + " sats";
                            div.getElementsByClassName( "expense_info" )[ 0 ].append( div2 );
                        });
                        try {
                            var txdata = tapscript.Tx.create({
                              vin  : proposal[ 1 ],
                              vout : proposal[ 2 ]
                            });
                            var txid = tapscript.Tx.util.getTxid( txdata );
                            var tx_exists = await checkIfTxHappened( txid );
                            if ( tx_exists ) proposal_should_go_in_past_proposals = true;
                        } catch( e ) {}
                        var fee_amount = from_amount - ( to_amount + change_amount );
                        if ( fee_amount < 1 && !proposal_should_go_in_past_proposals ) {
                            var number_of_visible_proposals = 0;
                            $$( '.current_proposals .proposal_div' ).forEach( item => {
                                if ( item.style.display != "none" ) number_of_visible_proposals = number_of_visible_proposals + 1;
                            });
                            if ( !number_of_visible_proposals ) $( '.none_currently' ).style.display = "block";
                            return;
                        }
                        var fee = document.createElement( "div" );
                        fee.className = "fee_parent";
                        fee.innerHTML = `<p>Mining fee: ${fee_amount} sats</p>`;
                        //check for low fees and warn if too low
                        var size_of_each_input = 0;
                        var temp_multisig = [...multisig];
                        threshold = temp_multisig[ 0 ];
                        temp_multisig.splice( 0, 1 );
                        var i; for ( i=0; i<temp_multisig.length; i++ ) {
                            size_of_each_input = size_of_each_input + ( 64 + 32 + 8 );
                        }
                        var txsize = 0;
                        var i; for ( i=0; i<proposal[ 1 ].length; i++ ) {
                            txsize = txsize + size_of_each_input;
                        }
                        var i; for ( i=0; i<proposal[ 2 ].length; i++ ) {
                            //I calculate that outputs add 30 bytes apiece by
                            //assuming the average scriptpubkey is 26 bytes
                            //and assuming amounts are denoted in 4 bytes
                            txsize = txsize + 30;
                        }
                        var fee_options = await getThreeFeeRates( mempoolNetwork );
                        var min_fee = fee_options[ 0 ];
                        min_fee = ( Number( min_fee ) * txsize ) - 30;
                        //I subtracted 30 because the parent transaction often-but-not-always
                        //adds an additional change output after calculating the feerate, so
                        //that makes it too-frequently trigger the fee warning -- also, I am
                        //overestimating fees anyway due to not understanding how the witness
                        //discount works so this should be safe
                        if ( fee_amount < min_fee ) fee.innerHTML += `<p class="fee_warning">Warning, this is a low fee, likely to be rejected by miners. The estimated size of this transaction is ${txsize} bytes and the lowest feerate that most mempools accept right now is ${fee_options[ 0 ]} sat per byte. That means your tx should pay at least ${min_fee} sats as a fee. Be careful what you sign.</p>`;
                        div.getElementsByClassName( "expense_info" )[ 0 ].append( fee );
                    }
                    var buttons = document.createElement( "div" );
                    buttons.className = "approve_or_deny";
                    buttons.innerHTML = `<p><button class="approve approve_${event.id}">Approve</button> <button class="deny deny_${event.id}">Deny</button></p>`;
                    div.append( buttons );
                    var inputs_and_outputs = document.createElement( "div" );
                    inputs_and_outputs.style = "display: none;";
                    inputs_and_outputs.innerHTML = `
                        <div class="inputs"></div>
                        <div class="outputs"></div>
                    `;
                    inputs_and_outputs.getElementsByClassName( "inputs" )[ 0 ].innerText = JSON.stringify( proposal[ 1 ] );
                    inputs_and_outputs.getElementsByClassName( "outputs" )[ 0 ].innerText = JSON.stringify( proposal[ 2 ] );
                    div.append( inputs_and_outputs );
                    div.getElementsByClassName( "deny" )[ 0 ].onclick = async e => {
                        var prop_id = e.target.classList[ 1 ].substring( e.target.classList[ 1 ].indexOf( "_" ) + 1 );
                        $( `.proposal_${prop_id} .approve` ).disabled = true;
                        $( `.proposal_${prop_id} .deny` ).disabled = true;
                        var seckey = sessionStorage[ "myprivkey" ];
                        var pubKey = nobleSecp256k1.getPublicKey( seckey, true ).substring( 2 );
                        var reply = {
                            "content"    : "",
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"       : 2860,
                            "tags"       : [ [ "e", event.id ] ],
                            "pubkey"     : pubKey,
                        }
                        var signedEvent = await getSignedEvent(reply, seckey);
                        var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                            var myrelay = Object.keys( relays )[ i ];
                            if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                            relays[ myrelay ].addEventListener( "message", handleMessage );
                            relays[ myrelay ].send(JSON.stringify([ "EVENT", signedEvent ]));
                            await waitSomeSeconds( 2 );
                            relays[ myrelay ].close();
                        }
                        console.log( "denied!" );
                        // window.location.reload();
                    }
                    div.getElementsByClassName( "approve" )[ 0 ].onclick = async e => {
                        var prop_id = e.target.classList[ 1 ].substring( e.target.classList[ 1 ].indexOf( "_" ) + 1 );
                        $( `.proposal_${prop_id} .approve` ).disabled = true;
                        $( `.proposal_${prop_id} .deny` ).disabled = true;
                        var inputs = proposal[ 1 ];
                        var outputs = proposal[ 2 ];
                        var seckey = sessionStorage[ "myprivkey" ];
                        var pubKey = nobleSecp256k1.getPublicKey( seckey, true ).substring( 2 );
                        if ( inputs.length && outputs.length ) {
                            var txdata = tapscript.Tx.create({
                              vin  : inputs,
                              vout : outputs
                            });
                            var temp_multisig = [...multisig];
                            var threshold = temp_multisig[ 0 ];
                            temp_multisig.splice( 0, 1 );
                            var script = [0];
                            temp_multisig.forEach( item => {
                                script.push( item, "OP_CHECKSIGADD" );
                            });
                            var pubkey = "ab".repeat( 32 );
                            script.push( threshold, "OP_EQUAL" );
                            var sbytes = tapscript.Script.encode( script );
                            var tapleaf = tapscript.Tap.tree.getLeaf( sbytes );
                            var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { target: tapleaf });
                            var all_sigs = [];
                            var i; for ( i=0; i<inputs.length; i++ ) {
                                var sig = tapscript.Signer.taproot.sign(seckey, txdata, i, { extension: tapleaf });
                                all_sigs.push( sig.hex );
                            }
                        } else {
                            var all_sigs = 1;
                        }
                        var reply = {
                            "content"    : JSON.stringify( all_sigs ),
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"       : 2860,
                            "tags"       : [ [ "e", event.id ] ],
                            "pubkey"     : pubKey,
                        }
                        var signedEvent = await getSignedEvent(reply, seckey);
                        var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                            var myrelay = Object.keys( relays )[ i ];
                            if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                            relays[ myrelay ].addEventListener( "message", handleMessage );
                            relays[ myrelay ].send(JSON.stringify([ "EVENT", signedEvent ]));
                        }
                        console.log( "approved!" );
                        // window.location.reload();
                    }
                    var sigs_obtained = div.getElementsByClassName( "computed_proposal_info" )[ 0 ];
                    sigs_obtained.innerHTML = `
                        Approvals: <span class="sigs_obtained">0</span><br>
                        Denials: <span class="denys_obtained">0</span><br>
                        Approvals needed to pass: ${threshold}<br>
                        <div class="denials_needed">Denials needed to fail: ${( $$( '.profile' ).length - threshold ) + 1}<br></div>
                        <div class="num_of_respondents">Number of respondents so far: <span class="respondents_num">0</span> out of ${$$( '.profile' ).length}</div>
                    `;
                    if ( !proposal_should_go_in_past_proposals ) {
                        $( '.current_proposals' ).append( div );
                    } else {
                        $( '.no_past_proposals' ).style.display = "none";
                        div.getElementsByClassName( "approve_or_deny" )[ 0 ].style.display = "none";
                        if ( div.getElementsByClassName( "fee_parent" )[ 0 ] ) div.getElementsByClassName( "fee_parent" )[ 0 ].innerHTML = ``;
                        $( '.past_proposals' ).append( div );
                        $( `.past_proposals .proposal_${prop_id} .voters_undecided` ).classList.add( "hidden" );
                        $( `.past_proposals .proposal_${prop_id} .countdown_div` ).classList.add( "hidden" );
                    }
                    if ( sessionStorage[ "myprivkey" ] ) {
                        $$( '.current_proposals .approve_or_deny' ).forEach( item => {
                            item.style.display = "block";
                        });
                        $$( '.current_proposals .fee_warning' ).forEach( item => {
                            item.style.display = "block";
                        });
                    }
                    $( '.cprops' ).innerText = $$( `.current_proposals .proposal_div` ).length;
                    $( '.pprops' ).innerText = $$( `.past_proposals .proposal_div` ).length;
                    var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                        var myrelay = Object.keys( relays )[ i ];
                        if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                        var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).toString( "hex" ).substring( 0, 24 );
                        var filter = { authors: temp_multisig, kinds: [ 2860 ], "#e": [ event.id ] }
                        var subscription = [ "REQ", subId, filter ];
                        relays[ myrelay ].addEventListener( "message", handleMessage );
                        relays[ myrelay ].send( JSON.stringify( subscription ) );
                    }
                }
                if ( kind === 2860 ) {
                    var temp_multisig = [...multisig];
                    threshold = temp_multisig[ 0 ];
                    temp_multisig.splice( 0, 1 );
                    var proposal = event.tags[ 0 ][ 1 ];
                    if ( event.pubkey == sessionStorage[ "mypubkey" ] ) {
                        $( `.proposal_${proposal} .approve` ).disabled = true;
                        $( `.proposal_${proposal} .deny` ).disabled = true;
                    }
                    if ( !content ) {
                        if ( proposal in denys && Object.keys( denys[ proposal ] ).length > ( $$( '.profile' ).length - threshold ) + 1 ) return;
                        if ( !( proposal in denys ) ) denys[ proposal ] = {};
                        var deny_exists_already = false;
                        Object.keys( denys[ proposal ] ).every( item => {
                            if ( item == event.pubkey ) {
                                deny_exists_already = true;
                                return;
                            }
                            return true;
                        });
                        if ( deny_exists_already ) return;
                        denys[ proposal ][ event.pubkey ] = 1;
                        if ( event.pubkey == sessionStorage[ "mypubkey" ] ) {
                            $( `.proposal_${proposal} .approve` ).disabled = true;
                            $( `.proposal_${proposal} .deny` ).disabled = true;
                        }
                        $$( `.proposal_${proposal}` ).forEach( item => {
                            var denys_obtained = item.getElementsByClassName( "denys_obtained" )[ 0 ];
                            var respondents_num = item.getElementsByClassName( "respondents_num" )[ 0 ];
                            var voters_against = item.getElementsByClassName( "voters_against" )[ 0 ];
                            var undecideds = item.getElementsByClassName( `undecided_${event.pubkey}` )[ 0 ];
                            var approve_or_deny = item.getElementsByClassName( `approve_or_deny` )[ 0 ];
                            var fee_parent = item.getElementsByClassName( `fee_parent` )[ 0 ];
                            var voters_undecided = item.getElementsByClassName( `voters_undecided` )[ 0 ];
                            var countdown_div = item.getElementsByClassName( `countdown_div` )[ 0 ];
                            denys_obtained.innerText = Number( denys_obtained.innerText ) + 1;
                            respondents_num.innerText = Number( respondents_num.innerText ) + 1;
                            var html = voters_against.innerHTML;
                            html += `
                                <div class="proposal_author" style="margin: 0.5rem; float: none;">
                                    <div class="proposal_author_pic" style="background-image: url( '${members[ event.pubkey ][ "pic" ]}' )"></div>
                                    <div class="proposal_author_nym">${members[ event.pubkey ][ "nym" ]}</div>
                                </div>
                            `;
                            voters_against.innerHTML = html;
                            voters_against.classList.remove( "hidden" );
                            undecideds.classList.add( "hidden" );
                            if ( Number( denys_obtained.innerText ) < ( ( $$( '.profile' ).length - threshold ) + 1 ) ) return;
                            //make rejected proposals disappear
                            $( '.no_past_proposals' ).style.display = "none";
                            approve_or_deny.style.display = "none";
                            if ( $( `.proposal_${proposal} .fee_parent` ) ) $( `.proposal_${proposal} .fee_parent` ).innerHTML = ``;
                            $( '.past_proposals' ).append( item );
                            voters_undecided.classList.add( "hidden" );
                            countdown_div.classList.add( "hidden" );
                            $( '.pprops' ).innerText = $$( `.past_proposals .proposal_div` ).length;
                            $( '.cprops' ).innerText = $$( `.current_proposals .proposal_div` ).length;
                            var number_of_visible_proposals = 0;
                            $$( '.current_proposals .proposal_div' ).forEach( item => {
                                if ( item.style.display != "none" ) number_of_visible_proposals = number_of_visible_proposals + 1;
                            });
                            if ( !number_of_visible_proposals ) {
                                $( '.cprops' ).innerText = 0;
                                $( '.none_currently' ).style.display = "block";
                            }
                        });
                    } else {
                        if ( proposal in sigs && Object.keys( sigs[ proposal ] ).length >= threshold ) return;
                        if ( !( proposal in sigs ) ) sigs[ proposal ] = {};
                        if ( event.pubkey == sessionStorage[ "mypubkey" ] ) {
                            $( `.proposal_${proposal} .deny` ).disabled = true;
                            $( `.proposal_${proposal} .approve` ).disabled = true;
                        }
                        if ( !all_sigs ) var all_sigs = [];
                        if ( content != "1" ) {
                            JSON.parse( content ).forEach( item => {
                                all_sigs.push( item );
                            });
                        } else {
                            all_sigs.push( 1 );
                        }
                        //todo: fix the issue whereby these lines sometimes result in
                        //a proposal seeming to be approved multiple times by the same
                        //person
                        var sigs_exist_already = false;
                        Object.keys( sigs[ proposal ] ).every( item => {
                            if ( item == event.pubkey ) {
                                sigs_exist_already = true;
                                return;
                            }
                            return true;
                        });
                        if ( sigs_exist_already ) return;
                        if ( content != "1" ) {
                            //validate each signature
                            //but to do that I need the txdata and tapleaf
                            //because those give me the scripthash
                            //and to get the tapleaf I need the script
                            var script = [0];
                            temp_multisig.forEach( item => {
                                script.push( item, "OP_CHECKSIGADD" );
                            });
                            var pubkey = "ab".repeat( 32 );
                            script.push( threshold, "OP_EQUAL" );
                            var sbytes = tapscript.Script.encode( script );
                            var tapleaf = tapscript.Tap.tree.getLeaf( sbytes );
                            var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { target: tapleaf });
                            var inputs = JSON.parse( $( `.proposal_${proposal} .inputs` ).innerText );
                            var outputs = JSON.parse( $( `.proposal_${proposal} .outputs` ).innerText );
                            //now I have the script and tapleaf but I still need the txdata
                            var txdata = tapscript.Tx.create({
                              vin  : inputs,
                              vout : outputs
                            });
                            //now I can validate each signature
                            var all_sigs_are_valid = true;
                            var i; for ( i=0; i<inputs.length; i++ ) {
                                var sighash = tapscript.Signer.taproot.hash( txdata, i, { extension: tapleaf } );
                                try {
                                    var is_valid = await nobleSecp256k1.schnorr.verify( all_sigs[ i ], bytesToHex( sighash ), event.pubkey );
                                } catch ( e ) {
                                    var is_valid = false;
                                }
                                if ( !is_valid ) all_sigs_are_valid = false;
                            }
                            if ( !all_sigs_are_valid ) return;
                        }
                        if ( proposal in sigs && event.pubkey in sigs[ proposal ] && sigs[ proposal ][ event.pubkey ].length ) return;
                        sigs[ proposal ][ event.pubkey ] = all_sigs;
                        $( `.proposal_${proposal} .sigs_obtained` ).innerText = Number( $( `.proposal_${proposal} .sigs_obtained` ).innerText ) + 1;
                        $( `.proposal_${proposal} .respondents_num` ).innerText = Number( $( `.proposal_${proposal} .respondents_num` ).innerText ) + 1;
                        var html = $( `.proposal_${proposal} .voters_for` ).innerHTML;
                        html += `
                            <div class="proposal_author" style="margin: 0.5rem; float: none;">
                                <div class="proposal_author_pic" style="background-image: url( '${members[ event.pubkey ][ "pic" ]}' )"></div>
                                <div class="proposal_author_nym">${members[ event.pubkey ][ "nym" ]}</div>
                            </div>
                        `;
                        $( `.proposal_${proposal} .voters_for` ).innerHTML = html;
                        $( `.proposal_${proposal} .voters_for` ).classList.remove( "hidden" );
                        $( `.proposal_${proposal} .undecided_${event.pubkey}` ).classList.add( "hidden" );
                        if ( Object.keys( sigs[ proposal ] ).length != threshold ) return;
                        var i; for ( i=0; i<JSON.parse( content ).length; i++ ) {
                            //put sigs in reverse order of multisig keys
                            var sigs_array = [];
                            temp_multisig.reverse();
                            temp_multisig.forEach( item => {
                                if ( Object.keys( sigs[ proposal ] ).includes( item ) ) {
                                    sigs_array.push( sigs[ proposal ][ item ][ i ] );
                                } else {
                                    sigs_array.push( "" );
                                }
                            });
                            var sig_counter = 0;
                            sigs_array.forEach( (item, index) => {
                                if ( sig_counter == threshold ) sigs_array[ index ] = "";
                                if ( sigs_array[ index ] ) {
                                    sig_counter = sig_counter + 1;
                                }
                            });
                            temp_multisig.reverse();
                            if ( txdata ) txdata.vin[ i ].witness = [ ...sigs_array, script, cblock ];
                        }
                        if ( txdata && !dont_broadcast.includes( proposal ) ) {
                            var txid = await pushBTCpmt( tapscript.Tx.encode( txdata ).hex, mempoolNetwork );
                            sessionStorage[ "loop_num" ] = "2";
                        } else if ( txdata ) {
                            //I am disabling this else statement because I don't think I need it anymore
                            //but I am not sure so I am keeping it aroud just in case
                            //it used to rebroadcast transactions that should have been broadcast but
                            //were accidentally not broadcasted -- but I do not think that is necessary
                            //now because of the new way I put things into the dont_broadcast category,
                            //which I now only do if the transaction's inputs don't exist
                            // var txid = tapscript.Tx.util.getTxid( txdata );
                            // var tx_exists = await checkIfTxHappened( txid );
                            // if ( !tx_exists ) {
                            //     var rand = Math.floor( Math.random() * 3000 );
                            //     setTimeout( function() {
                            //         pushBTCpmt( tapscript.Tx.encode( txdata ).hex, mempoolNetwork );
                            //     }, Number( rand ) + 1000 );
                            // }
                        }
                        var it_was_only_a_statement = true;
                        Object.keys( sigs[ proposal ] ).forEach( item => {
                            if ( sigs[ proposal ][ item ] != 1 ) it_was_only_a_statement = false;
                        });
                        $( `.proposal_${proposal} .approve_or_deny` ).style.display = "none";
                        if ( it_was_only_a_statement ) {
                            $( '.no_statements' ).style.display = "none";
                            $( '.statements' ).append( $( `.proposal_${proposal}` ) );
                            $( `.statements .proposal_${proposal} .voters_undecided` ).classList.add( "hidden" );
                            $( `.statements .proposal_${proposal} .countdown_div` ).classList.add( "hidden" );
                            var second_statement = $( `.proposal_${proposal}` ).cloneNode( true );
                            $( '.no_past_proposals' ).style.display = "none";
                            if ( $( `.proposal_${proposal} .fee_parent` ) ) $( `.proposal_${proposal} .fee_parent` ).innerHTML = ``;
                            $( '.past_proposals' ).append( second_statement );
                        } else {
                            $( '.no_past_proposals' ).style.display = "none";
                            if ( $( `.proposal_${proposal} .fee_parent` ) ) $( `.proposal_${proposal} .fee_parent` ).innerHTML = ``;
                            $( '.past_proposals' ).append( $( `.proposal_${proposal}` ) );
                            if ( txdata ) {
                                try {
                                    var tx = tapscript.Tx.decode( tapscript.Tx.encode( txdata ).hex );
                                    var txid = tapscript.Tx.util.getTxid( tx );
                                } catch ( e ) {
                                    console.log( "error 0:", txdata );
                                    var tx = tapscript.Tx.decode( tapscript.Tx.encode( txdata ).hex );
                                    console.log( "error 1:", tx );
                                    var txid = tapscript.Tx.util.getTxid( tx );
                                    console.log( "error 2:", txid );
                                }
                            }
                            if ( txdata && $( `.proposal_${proposal} .fee_parent` ) ) $( `.proposal_${proposal} .fee_parent` ).innerHTML = `<p><a href="https://mempool.space/${mempoolNetwork}tx/${txid}" target="_blank" data-txhex="${tapscript.Tx.encode( txdata ).hex}" onclick='pushBTCpmt( this.getAttribute( "data-txhex" ), "${mempoolNetwork}" )'>View this transaction</a></p>`;
                        }
                        $( '.pprops' ).innerText = $$( `.past_proposals .proposal_div` ).length;
                        $( '.cprops' ).innerText = $$( `.current_proposals .proposal_div` ).length;
                        var number_of_visible_proposals = 0;
                        $$( '.current_proposals .proposal_div' ).forEach( item => {
                            if ( item.style.display != "none" ) number_of_visible_proposals = number_of_visible_proposals + 1;
                        });
                        if ( !number_of_visible_proposals ) {
                            $( '.cprops' ).innerText = 0;
                            $( '.none_currently' ).style.display = "block";
                        }
                        if ( txdata && !dont_broadcast.includes( proposal ) ) showModal( `The transaction was approved! You can view it here: https://mempool.space/${mempoolNetwork}tx/${txid}` );
                    }
                }
            }
            function waitSomeSeconds(num) {
                var num = num.toString() + "000";
                num = Number(num);
                return new Promise(resolve => setTimeout(resolve, num));
            }
            function prepend(value, array) {
              var newArray = array.slice();
              newArray.unshift(value);
              return newArray;
            }
            async function getSignedEvent(event, privateKey) {
                var eventData = JSON.stringify([
                    0,                  // Reserved for future use
                    event['pubkey'],        // The sender's public key
                    event['created_at'],    // Unix timestamp
                    event['kind'],      // Message “kind” or type
                    event['tags'],      // Tags identify replies/recipients
                    event['content']        // Your note contents
                ])
                event.id  = sha256( eventData ).toString( 'hex' );
                event.sig = await schnorr.sign( event.id, privateKey );
                return event;
            }
            var spendCoins = async () => {
                var inputs = [];
                var outputs = [];
                if ( $( '.will_spend' ).checked ) {
                    var temp_multisig = [...multisig];
                    var threshold = temp_multisig[ 0 ];
                    temp_multisig.splice( 0, 1 );
                    var script = [0];
                    temp_multisig.forEach( item => {
                        script.push( item, "OP_CHECKSIGADD" );
                    });
                    var pubkey = "ab".repeat( 32 );
                    script.push( threshold, "OP_EQUAL" );
                    var sbytes = tapscript.Script.encode( script );
                    var tapleaf = tapscript.Tap.tree.getLeaf( sbytes );
                    var [ tpubkey, cblock ] = tapscript.Tap.getPubKey(pubkey, { target: tapleaf });
                    var utxos = JSON.parse( sessionStorage[ "utxos" ] );
                    var from_amount = 0;
                    utxos.forEach( utxo => {
                        from_amount = from_amount + utxo[ 2 ];
                        var txid = utxo[ 0 ];
                        var vout = utxo[ 1 ];
                        var amt = utxo[ 2 ];
                        inputs.push({
                            txid: txid,
                            vout: vout,
                            prevout: {
                                value: amt,
                                scriptPubKey: [ 'OP_1', tpubkey ]
                            },
                        });
                    });
                    if ( !from_amount ) {
                        showModal( "You cannot spend without money. Please make a deposit, then try again." );
                        return;
                    }
                    var to_amount = 0;
                    var there_be_dust = false;
                    $$( '.add_outputs .output_addy' ).forEach( (item, index) => {
                        outputs.push({
                            value: Number( $$( '.add_outputs .output_amt' )[ index ].value ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( item.value )
                        });
                        to_amount = to_amount + Number( $$( '.add_outputs .output_amt' )[ index ].value );
                        if ( Number( $$( '.add_outputs .output_amt' )[ index ].value ) < 546 ) there_be_dust = true;
                    });
                    if ( there_be_dust ) {
                        showModal( "You cannot send less than 546 sats because that is bitcoin's dust limit. Please try again" );
                        return;
                    }
                    if ( from_amount - to_amount < 1 ) {
                        showModal( "You must leave enough to pay a mining fee, please try again" );
                        return;
                    }
                    console.log( "from amount:", from_amount, "to amount:", to_amount );
                    var size_of_each_input = 0;
                    var i; for ( i=0; i<temp_multisig.length; i++ ) {
                        size_of_each_input = size_of_each_input + ( 64 + 32 + 8 );
                    }
                    var txsize = 0;
                    var i; for ( i=0; i<inputs.length; i++ ) {
                        txsize = txsize + size_of_each_input;
                    }
                    var i; for ( i=0; i<outputs.length; i++ ) {
                        //I calculate that outputs add 30 bytes apiece by
                        //assuming the average scriptpubkey is 26 bytes
                        //and assuming amounts are denoted in 4 bytes
                        txsize = txsize + 30;
                    }
                    var fee_options = await getThreeFeeRates( mempoolNetwork );
                    var sats_per_byte = prompt( `Please enter a fee rate as a number. Specifically, the number of sats per byte you want to pay. The minimum rate is ${fee_options[ 0 ]}, the average rate is ${fee_options[ 1 ]}, and the urgent rate is ${fee_options[ 2 ]}.` );
                    sats_per_byte = Number( sats_per_byte );
                    if ( !sats_per_byte ) {
                        showModal( "You entered an invalid fee rate. You must enter a number greater than 0, such as 5, 10, or 25. Please try again." );
                        return;
                    }
                    var mining_fee = txsize * sats_per_byte;
                    if ( mining_fee < 172 ) mining_fee = 172;
                    if ( from_amount - to_amount < mining_fee ) {
                        showModal( `With your chosen fee rate you must leave at least ${mining_fee} sats to pay for mining fees, which means the max you can spend is ${from_amount - mining_fee} sats. Please try again` );
                        return;
                    }
                    if ( from_amount - ( to_amount + mining_fee ) >= 546 ) {
                        outputs.push({
                            value: from_amount - ( to_amount + mining_fee ),
                            scriptPubKey: tapscript.Address.toScriptPubKey( $( '.addy' ).innerText )
                        });
                    }
                }
                var seckey = sessionStorage[ "myprivkey" ];
                var pubKey = nobleSecp256k1.getPublicKey( seckey, true ).substring( 2 );
                var proposal = [$( '.proposal_desc' ).value, inputs, outputs];
                if ( $( '.statement' ).value ) proposal.push( $( '.statement' ).value );
                proposal = JSON.stringify( proposal );
                var event = {
                    "content"    : proposal,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 2859,
                    "tags"       : [ [ "e", $_GET[ "multisig" ] ] ],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await getSignedEvent(event, seckey);
                var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                    var myrelay = Object.keys( relays )[ i ];
                    if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                    relays[ myrelay ].addEventListener( "message", handleMessage );
                    relays[ myrelay ].send(JSON.stringify([ "EVENT", signedEvent ]));
                }
                setTimeout( function() {$( '.menu_cprops' ).click();}, 1500 );
            }
            function addOutput( element ) {
                if ( element ) {
                    element.previousElementSibling.style.display = "inline-block";
                }
                if ( $( '.output_plus_button' ) ) {
                    $( '.output_plus_button' ).remove();
                }
                var output_addy = document.createElement( "input" );
                output_addy.type = "text";
                output_addy.className = "output_addy";
                output_addy.placeholder = "address";
                var output_amt = document.createElement( "input" );
                output_amt.type = "number";
                output_amt.className = "output_amt";
                output_amt.placeholder = "amount (in sats)";
                $( '.add_outputs' ).append( output_addy );
                $( '.add_outputs' ).append( output_amt );
                var minus = document.createElement( "div" );
                minus.className = "minus_button";
                minus.innerText = "-";
                minus.onclick = function() {this.previousElementSibling.remove();this.previousElementSibling.remove();this.remove();}
                $( '.add_outputs' ).append( minus );
                var plus = document.createElement( "div" );
                plus.className = "output_plus_button";
                plus.innerText = "+";
                plus.onclick = function() {addOutput( this );}
                $( '.add_outputs' ).append( plus );
            }
            async function getBitcoinPriceFromCoinbase() {
                    var data = await getData( "https://api.coinbase.com/v2/prices/BTC-USD/spot" );
                    if ( data == "error" ) return 0;
                    var json = JSON.parse( data );
                    var price = json[ "data" ][ "amount" ];
                    return price;
            }
            async function getBitcoinPriceFromKraken() {
                    var data = await getData( "https://api.kraken.com/0/public/Ticker?pair=XBTUSD" );
                    if ( data == "error" ) return 0;
                    var json = JSON.parse( data );
                    var price = json[ "result" ][ "XXBTZUSD" ][ "a" ][ 0 ];
                    return price;
            }
            async function getBitcoinPriceFromCoindesk() {
                    var data = await getData( "https://api.coindesk.com/v1/bpi/currentprice.json" );
                    if ( data == "error" ) return 0;
                    var json = JSON.parse( data );
                    var price = json[ "bpi" ][ "USD" ][ "rate_float" ];
                    return price;
            }
            async function getBitcoinPriceFromGemini() {
                    var data = await getData( "https://api.gemini.com/v2/ticker/BTCUSD" );
                    if ( data == "error" ) return 0;
                    var json = JSON.parse( data );
                    var price = json[ "bid" ];
                    return price;
            }
            async function getBitcoinPriceFromCoinGecko() {
                    var data = await getData( "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&precision=2" );
                    if ( data == "error" ) return 0;
                    var json = JSON.parse( data );
                    var price = json[ "bitcoin" ][ "usd" ];
                    return price;
            }
            async function getBitcoinPrice() {
                var prices = [];
                var cbprice = await getBitcoinPriceFromCoinbase();
                var kprice = await getBitcoinPriceFromKraken();
                var cdprice = await getBitcoinPriceFromCoindesk();
                var gprice = await getBitcoinPriceFromGemini();
                var cgprice = await getBitcoinPriceFromCoinGecko();
                prices.push( Number( cbprice ), Number( kprice ), Number( cdprice ), Number( gprice ), Number( cgprice ) );
                prices.sort();
                sessionStorage[ "btc_price" ] = prices[ 2 ];
                return prices[ 2 ];
            }
            async function satsToDollars( sats ) {
                if ( sats >= 100000000 ) sats = sats * 10;
                if ( !sessionStorage[ "btc_price" ] ) await getBitcoinPrice();
                var bitcoin_price = Number( sessionStorage[ "btc_price" ] );
                var value_in_dollars = Number( String( sats ).padStart( 8, "0" ).slice( 0,-9 ) + "." + String( sats ).padStart( 8, "0" ).slice( -9 ) ) * bitcoin_price;
                return value_in_dollars;
            }
            function getData( url ) {
                return new Promise( async function( resolve, reject ) {
                    function inner_get( url ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.open( "GET", url, true );
                        xhttp.send();
                        return xhttp;
                    }
                    var data = inner_get( url );
                    data.onerror = function( e ) {
                        resolve( "error" );
                    }
                    async function isResponseReady() {
                        return new Promise( function( resolve2, reject ) {
                            if ( !data.responseText || data.readyState != 4 ) {
                                setTimeout( async function() {
                                    var msg = await isResponseReady();
                                    resolve2( msg );
                                }, 1 );
                            } else {
                                resolve2( data.responseText );
                            }
                        });
                    }
                    var returnable = await isResponseReady();
                    resolve( returnable );
                });
            }
            function getUTXOs( address, network ) {
                return new Promise( function( resolve, reject ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.onreadystatechange = function() {
                        if ( this.readyState == 4 && this.status == 200 ) {
                            var esplorautxos = JSON.parse( xhttp.responseText );
                            var utxos = [];
                            esplorautxos.forEach( function( item, index ) {
                                var utxo = [];
                                utxo.push( item[ "txid" ] );
                                utxo.push( item[ "vout" ] );
                                utxo.push( item[ "value" ] );
                                utxos.push( utxo );
                            });
                            resolve( utxos );
                        }
                    }
                    xhttp.open( "GET", `https://mempool.space/${network}api/address/` + address + "/utxo", true );
                    xhttp.send();
                });
            }
            async function getThreeFeeRates( network ) {
                var fees = await getData("https://mempool.space/" + network + "api/v1/fees/recommended");
                fees = JSON.parse(fees);
                var array = [ fees["minimumFee"], fees["hourFee"], fees["fastestFee"] ];
                return array;
            }
            function dotLoop(string) {
                if (!$('.dots')) {
                    setTimeout(function () {
                        dotLoop(string);
                    }, 1000);
                    return;
                }
                if (string.length < 3) {
                    string = string + ".";
                } else {
                    string = ".";
                }
                $$('.dots').forEach( item => {
                    item.innerText = string;
                });
                setTimeout(function () {
                    dotLoop(string);
                }, 1000);
            }
            async function pushBTCpmt( rawtx, network ) {
                var txid = await postData( "https://mempool.space/" + network + "api/tx", rawtx );
                return txid;
            }
            async function postData( url, json, content_type = "", apikey = "" ) {
                var rtext = "";
                function inner_post( url, json, content_type = "", apikey = "" ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "POST", url, true );
                    if ( content_type ) {
                        xhttp.setRequestHeader( `Content-Type`, content_type );
                    }
                    if ( apikey ) {
                        xhttp.setRequestHeader( `X-Api-Key`, apikey );
                    }
                    xhttp.send( json );
                    return xhttp;
                }
                var data = inner_post( url, json, content_type, apikey );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            function createQR( content ) {
                var dataUriPngImage = document.createElement( "img" ),
                s = QRCode.generatePNG( content, {
                    ecclevel: "M",
                    format: "html",
                    fillcolor: "#FFFFFF",
                    textcolor: "#000000",
                    margin: 4,
                    modulesize: 8,
                });
                dataUriPngImage.src = s;
                dataUriPngImage.className = "qr_code";
                return dataUriPngImage;
            }
            var showPage = ( page ) => {
                if ( page == "login_form" && !sessionStorage.myprivkey ) return login_fn();
                $( '.members' ).style.display = "none";
                $( '.balance' ).style.display = "none";
                $( '.statements' ).style.display = "none";
                $( '.current_proposals' ).style.display = "none";
                $( '.past_proposals' ).style.display = "none";
                $( '.easy_sign_in' ).style.display = "none";
                $( '.crafter' ).style.display = "none";
                if ( sessionStorage.myprivkey && page == "login_form" ) page = "crafter";
                $( `.${page}` ).style.display = "block";
                $( `.${page}` ).classList.remove( "hidden" );
            }
            var login_fn = myprivkey => {
                if ( !myprivkey ) {
                    var nsec = prompt( "Enter your nsec" );
                    if ( !nsec ) return;
                    var myprivkey = privkeyFromNsec( nsec );
                }
                var mypubkey = nobleSecp256k1.getPublicKey( myprivkey, true ).substring( 2 );
                if ( !multisig.includes( mypubkey ) ) return showModal( "Sorry, it looks like you are not a keyholder in this bitpac" );
                sessionStorage[ "myprivkey" ] = myprivkey;
                sessionStorage[ "mypubkey" ] = mypubkey;
                $( '.menu_login_or_create' ).innerText = "Craft proposal";
                $( '.menu_easy_sign_in' ).classList.remove( "hidden" );                
                $$( '.current_proposals .approve_or_deny' ).forEach( item => {
                    item.style.display = "block";
                });
                $$( '.current_proposals .fee_warning' ).forEach( item => {
                    item.style.display = "block";
                });
                Object.keys( sigs ).forEach( item => {
                    Object.keys( sigs[ item ] ).forEach( item2 => {
                        if ( item2 == sessionStorage[ "mypubkey" ] ) {
                            $( `.proposal_${item} .approve` ).disabled = true;
                            $( `.proposal_${item} .deny` ).disabled = true;
                        }
                    });
                });
                Object.keys( denys ).forEach( item => {
                    Object.keys( denys[ item ] ).forEach( item2 => {
                        if ( item2 == sessionStorage[ "mypubkey" ] ) {
                            $( `.proposal_${item} .approve` ).disabled = true;
                            $( `.proposal_${item} .deny` ).disabled = true;
                        }
                    });
                });
            }
            function modalVanish() {
                $( ".black-bg" ).style.display = "none";
                $( ".modal" ).style.display = "none";
            }
            function showModal( content ) {
                $( ".modal" ).innerHTML = `<div style="position: absolute;right: 1rem;top: 0.5rem;font-size: 2rem; cursor: pointer; color: black;" onclick="modalVanish()">&times;</div>`;
                $( ".modal" ).innerHTML += `<div style="overflow-y: scroll; max-height: 80vh; margin-top: 1.5rem;">${content}</div>`;
                $( ".black-bg" ).style.display = "block";
                $( ".modal" ).style.display = "block";
            }
            var fixReadyState = async relay => {
                if ( bad_relays[ relay ] > 9 ) {
                    delete relays[ relay ];
                    setTimeout( function() {
                        relays[ relay ] = null;
                        bad_relays[ relay ] = 0;
                    }, 30000 );
                    return;
                }
                var relay_is_good = !!relays[ relay ] && relays[ relay ].readyState == 1;
                if ( !!relays[ relay ] ) {
                    if ( relays[ relay ].readyState == 1 ) {
                        var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                            var myrelay = Object.keys( relays )[ i ];
                            if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                            if ( !$_GET[ "multisig"] ) continue;
                            relays[ myrelay ].addEventListener( "message", handleMessage );
                            var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).toString( "hex" ).substring( 0, 24 );
                            var filter  = { "ids": [ $_GET[ "multisig"] ] }
                            var subscription = [ "REQ", subId, filter ];
                            relays[ myrelay ].send( JSON.stringify( subscription ) );
                        }
                        return true;
                    } else {
                        relays[ relay ].close();
                        relays[ relay ] = new WebSocket( relay );
                        await waitSomeSeconds( 1 );
                        if ( relays[ relay ] && relays[ relay ].readyState == 1 ) {
                            var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                                var myrelay = Object.keys( relays )[ i ];
                                if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                                if ( !$_GET[ "multisig"] ) continue;
                                relays[ myrelay ].addEventListener( "message", handleMessage );
                                var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).toString( "hex" ).substring( 0, 24 );
                                var filter  = { "ids": [ $_GET[ "multisig"] ] }
                                var subscription = [ "REQ", subId, filter ];
                                relays[ myrelay ].send( JSON.stringify( subscription ) );
                            }
                            return true;
                        }
                    }
                } else {
                    relays[ relay ] = new WebSocket( relay );
                }
                await waitSomeSeconds( 1 );
                console.log( "fixing this relay:", relay );
                bad_relays[ relay ] = bad_relays[ relay ] + 1;
                return fixReadyState( relay );
            }
            var waitForBalanceToLoad = async () => {
                if ( !isNaN( $( '.bitpac_balance_sats' ).innerText ) ) return $( '.none_currently' ).innerHTML = `None currently`;
                if ( $( '.none_currently' ).innerText == "None currently" ) $( '.none_currently' ).innerHTML = `Loading<span class="dots">.</span>`;
                await waitSomeSeconds( 1 );
                return waitForBalanceToLoad();
            }
            var waitForOneRelay = async ( waiting_for_damus ) => {
                await waitSomeSeconds( 1 );
                if ( waiting_for_damus && relays[ "wss://relay.damus.io" ] && relays[ "wss://relay.damus.io" ].readyState == 1 ) {
                    return;
                } else if ( waiting_for_damus ) {
                    return waitForOneRelay( true );
                }
                var relay_is_ready = false;
                Object.keys( relays ).every( item => {
                    if ( relays[ item ] && relays[ item ].readyState == 1 ) {
                        relay_is_ready = true;
                        return;
                    }
                    return true;
                });
                if ( !relay_is_ready ) {
                    return waitForOneRelay();
                }
            }
            var checkIfTxHappened = async txid => {
                var data = await getData( `https://mempool.space/${mempoolNetwork}api/tx/${txid}` );
                if ( data != "Transaction not found" ) return true;
            }
            sessionStorage.removeItem( "ready_to_load_profiles" );
            sessionStorage.removeItem( "easy_sign_in_username" );
            sessionStorage.removeItem( "easy_sign_in_password" );
            async function getNote( item ) {
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ item ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ item ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
            var loadProfiles = async temp_multisig => {
                await getNote( "ready_to_load_profiles" );
                var i; for ( i=0; i<temp_multisig.length; i++ ) {
                    var item = temp_multisig[ i ];
                    var profile = document.createElement( "div" );
                    profile.className = `profile profile_${item}_${i}`;
                    profile.innerHTML = `
                        <div style="display: none;" class="profile_wrapper"><div class="pic"></div><div class="nym" style="color: black; word-wrap: break-word;"></div></div>
                    `;
                    $$( '.nostr_profiles' )[ 1 ].append( profile );
                }
                $$( '.profile' ).forEach( item => {
                    setTimeout( () => {
                        var innerText = item.firstElementChild.getElementsByClassName( "nym" )[ 0 ].innerText;
                        if ( !innerText || innerText === "undefined" ) {
                            var pubkey = item.classList[ 1 ];
                            pubkey = pubkey.substring( pubkey.indexOf( "_" ) + 1 );
                            pubkey = pubkey.substring( 0, pubkey.indexOf( "_" ) );
                            if ( !members[ pubkey ] ) members[ pubkey ] = {
                                nym: pubkey.substring( 0, 15 ) + "...",
                                pic: "https://upload.wikimedia.org/wikipedia/commons/a/ac/Default_pfp.jpg",
                            }
                            item.firstElementChild.getElementsByClassName( "nym" )[ 0 ].innerText = pubkey.substring( 0, 15 ) + "...";
                            item.firstElementChild.getElementsByClassName( "pic" )[ 0 ].style.backgroundImage = `url("https://upload.wikimedia.org/wikipedia/commons/a/ac/Default_pfp.jpg")`;
                            $( '.loading_profiles' ).style.display = "none";
                            item.firstElementChild.style.display = "inline-block";
                        }
                    }, 3000 );
                });
            }
            function convertHMS( value ) {
                if ( value < 0 ) value = 0;
                var sec = parseInt(value, 10); // convert value to number if it's string
                var years = Math.floor(sec / 31536000); // get years
                var months = Math.floor((sec - (years * 31536000)) / 2592000); // get months
                var days = Math.floor((sec - (years * 31536000) - (months * 2592000)) / 86400); // get days
                var hours = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400)) / 3600); // get hours
                var minutes = Math.floor((sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600)) / 60); // get minutes
                var seconds = sec - (years * 31536000) - (months * 2592000) - (days * 86400) - (hours * 3600) - (minutes * 60); //  get seconds
                var yearsstring = (years != 1) ? `years`:`year`;
                var monthsstring = (months != 1) ?  `months`:`month`;
                var daysstring = (days != 1) ? `days`:`day`;
                var hoursstring = (hours != 1) ? `hours`:`hour`;
                var minutesstring = (minutes != 1) ? `minutes`:`minute`;
                var secondsstring = (seconds != 1) ? `seconds`:`second`;
                if ( years > 0 ) return `${years} ${yearsstring}`;
                if ( months > 0 ) return `${months} ${monthsstring}`;
                if ( days > 0 ) return `${days} ${daysstring}`;
                if ( hours > 0 ) return `${hours} ${hoursstring}`;
                if ( minutes > 0 ) return `${minutes} ${minutesstring}`;
                if ( seconds == 0 ) return `${seconds} seconds`;
                return `${seconds} ${secondsstring}`;
            }
            function isValidHex( h ) {
                if ( !h ) return;
                var length = h.length;
                if ( length % 2 ) return;
                try {
                    var a = BigInt( "0x" + h, "hex" );
                } catch( e ) {
                    return;
                }
                var unpadded = a.toString( 16 );
                var padding = [];
                var i; for ( i=0; i<length; i++ ) padding.push( 0 );
                padding = padding.join( "" );
                padding = padding + unpadded.toString();
                padding = padding.slice( -Math.abs( length ) );
                return ( padding === h );
            }
            var getEcash = async ( temp_multisig, ecash_amounts, keyset ) => {
                var outputs = {}
                var i; for ( i=0; i<ecash_amounts.length; i++ ) {
                    var nonce_for_message = bytesToHex( blindSigJS.getRand( 16 ) );
                    var pubkeys_tag = [ "pubkeys" ];
                    var first_pubkey = "02" + temp_multisig[ 0 ];
                    temp_multisig.forEach( ( item, index ) => {if ( index ) pubkeys_tag.push( "02" + item )});
                    var secret_for_message = [
                        "P2PK",
                        {
                            "nonce": nonce_for_message,
                            "data": first_pubkey,
                            "tags": [
                                [ "sigflag", "SIG_ALL" ],
                                [ "n_sigs", String( threshold ) ],
                                pubkeys_tag,
                            ],
                        }
                    ];
                    secret_for_message = JSON.stringify( secret_for_message );
                    var message = new blindSigJS.bsjMsg();
                    var B_ = await message.createBlindedMessageFromString( secret_for_message );
                    var output_B_hex = blindSigJS.ecPointToHex( B_ );
                    var output = {
                        "amount": ecash_amounts[ i ],
                        "id": keyset,
                        "B_": output_B_hex,
                        message,
                        secret_for_message,
                    }
                    outputs[ `num_${ecash_amounts[ i ]}` ] = output;
                }
                return outputs;
            }
            var decomposeAmount = amount_to_decompose => {
                var decomposed = [];
                var getBaseLog = ( x, y ) => Math.log(y) / Math.log(x);
                var inner_fn = amt => {
                    var exponent = Math.floor( getBaseLog( 2, amt ) );
                    decomposed.push( 2 ** exponent );
                    amount_to_decompose = amt - 2 ** exponent;
                    if ( amount_to_decompose ) inner_fn( amount_to_decompose );
                }
                inner_fn( amount_to_decompose );
                return decomposed;
            }
            var recomposeAmount = amounts_to_recompose => {
                var recomposed = [];
                var sum = 0;
                amounts_to_recompose.forEach( item => sum = sum + item );
                return decomposeAmount( sum );
            }
            var resizer = async () => {
                if ( $( '.profile .pic' ) ) $$( '.profile .pic' ).forEach( item => {item.style.height = item.offsetWidth + "px"});
                await waitSomeSeconds( 0.05 );
                resizer();
            }
            var hexToBytes = hex => Uint8Array.from( hex.match( /.{1,2}/g ).map( byte => parseInt( byte, 16 ) ) );
            function getCompressedPubkeyHexFromUncompressedPubkeyHex( pubkeyhex ) {
                return bitcoinjs.ECPair.fromPublicKey( Buffer.from( pubkeyhex, "hex" ) ).publicKey.toString( "hex" );
            }
            var getEcashInputs = ( amt, ecash_inputs ) => {
                var input;
                ecash_inputs.every( item => {
                    if ( item[ "amount" ] == amt ) return input = item;
                    return true;
                });
                return [input];
            }
            var split_input = input => {
                var new_amt = Math.floor( input.amount / 2 );
                return [{amount: new_amt}, {amount: new_amt}];
            }
            var split_and_repeat = ( input, target, siblings_and_parents ) => {
                if ( !input.amount ) return alert( `error` );
                if ( input.amount == target ) return [ input, siblings_and_parents ];
                var halves = split_input( input );
                siblings_and_parents.push( halves[ 1 ] );
                return split_and_repeat( halves[ 0 ], target, siblings_and_parents );
            }
            blindSigJS.ecHexToPoint = hex => nobleSecp256k1.Point.fromHex( hex );
            blindSigJS.bigIntToHex = bigInt => bigInt.toString( 16 );
            blindSigJS.hexToBigInt = hex => BigInt( `0x${hex}` );
            var containsDuplicates = array => {array = array.map( JSON.stringify ); return array.length !== new Set(array).size}
            var arr_includes_obj = ( obj, arr ) => {
                var included = false;
                var i; for ( i=0; i<arr.length; i++ ) {
                    var item = arr[ i ];
                    if ( obj.amount == item.amount ) {included = true;break;}
                }
                return included;
            }
            var split_array = outer_array => {
                var array_of_arrays = [[]];
                var skip_til = 0;
                var array_splitter = ( array, skip_til ) => {
                    var item = array.splice( skip_til, 1 )[ 0 ];
                    if ( !arr_includes_obj( item, array ) ) {
                        array.unshift( item );
                        skip_til = skip_til + 1;
                    } else {
                        array_of_arrays.every( ( arr, index ) => {
                            if ( !arr_includes_obj( item, arr ) ) {array_of_arrays[ index ].push( item );}
                            else array_of_arrays.push( [item] );
                        });
                    }
                    if ( array.length && containsDuplicates( array ) ) array_splitter( array, skip_til );
                    else if ( array.length ) array_of_arrays.push( array );
                }
                array_splitter( outer_array, skip_til );
                array_of_arrays.forEach( item => item.sort( (a,b)=>a.amount-b.amount));
                return array_of_arrays;
            }
            function textToHex( text ) {
                var encoder = new TextEncoder().encode( text );
                return [...new Uint8Array(encoder)]
                    .map( x => x.toString( 16 ).padStart( 2, "0" ) )
                    .join( "" );
            }
            function hexToText( hex ) {
                var bytes = new Uint8Array(Math.ceil(hex.length / 2));
                for (var i = 0; i < hex.length; i++) bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
                var text = new TextDecoder().decode( bytes );
                return text;
            }
            function base64ToHex( str ) {
                var raw = atob( str );
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += ( hex.length === 2 ? hex : '0' + hex );
                }
                return result;
            }
            function encrypt( privkey, pubkey, text ) {
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var iv = window.crypto.getRandomValues(new Uint8Array(16));
                var cipher = browserifyCipher.createCipheriv( 'aes-256-cbc', hexToBytes( key ), iv );
                var encryptedMessage = cipher.update(text,"utf8","base64");
                emsg = encryptedMessage + cipher.final( "base64" );
                var uint8View = new Uint8Array( iv.buffer );
                var decoder = new TextDecoder();
                return emsg + "?iv=" + btoa( String.fromCharCode.apply( null, uint8View ) );
            }
            function decrypt( privkey, pubkey, ciphertext ) {
                var [ emsg, iv ] = ciphertext.split( "?iv=" );
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var decipher = browserifyCipher.createDecipheriv(
                    'aes-256-cbc',
                    hexToBytes( key ),
                    hexToBytes( base64ToHex( iv ) )
                );
                var decryptedMessage = decipher.update( emsg, "base64" );
                dmsg = decryptedMessage + decipher.final( "utf8" );
                return dmsg;
            }
        </script>
    </head>
    <body>
        <h1>Welcome to bitpac</h1>
        <div class="multisig_creator">
            <p>
                A bitpac is a publicly auditable cooperative that lives on bitcoin. Use this form to create a bitpac so that you and the other members of your cooperative can control some money and vote on how to spend it.
            </p>
            <p>Name your bitpac</p>
            <input class="bitpac_name">
            <p>Enter an npub for everyone in your bitpac</p>
            <div class="select_npubs">
            </div>
            <p>Pick how many votes are needed to spend the money</p>
            <input class="select_threshold" type="number" value="1" min="1" step="1" max="74">
            <p>Your policy so far: <span class="threshold_num">1</span> out of <span class="multisig_num">1</span></p>
            <div class="nostr_profiles"></div>
            <button class="create_bitpac">Submit</button>
        </div>
        <div class="multisig_viewer">
            <div class="loading">Loading<span class="dots">.</span></div>
        </div>
        <div class="easy_sign_in hidden">
            <h2>Easy sign in</h2>
            <p class="instructions_for_easy_sign_in">With bitpac, you don't need to copy/paste your nsec into the page every time you want to log in. You can create an "easy sign in" link where you just have to visit the link and then enter a username/password to access your bitpac. Create one below!</p>
            <p class="alternative_instructions_for_easy_sign_in hidden">Create a new easy sign in username and password below (but know that your old link will still work with your old username and password)</p>
            <h2>Desired username</h2>
            <p><input class="username"></p>
            <h2>Desired password</h2>
            <p><input type="password" class="password"></p>
            <p><button class="submit_easy_sign_in">Submit</button></p>
        </div>
        <script>
            $( '.submit_easy_sign_in' ).onclick = () => {
                var username = $( '.username' ).value;
                var password = $( '.password' ).value;
                if ( !username ) return showModal( `You forgot to enter a username, please try again` );
                if ( !password ) return showModal( `You forgot to enter a password, please try again` );
                var hashable = String( username ) + String( password );
                hashable = hexToBytes( textToHex( hashable ) );
                var sign_in_privkey = bytesToHex( sha256( hashable ) );
                var sign_in_pubkey = nobleSecp256k1.getPublicKey( sign_in_privkey, true ).substring( 2 );
                var my_encrypted_privkey = encrypt( sign_in_privkey, sign_in_pubkey, sessionStorage[ "myprivkey" ] );
                var bech32_encoded_encrypted_privkey = bech32.bech32m.encode( "esi", bech32.bech32m.toWords( Buffer.from( textToHex( my_encrypted_privkey ), "hex" ) ), 10000 );
                var url = window.location.href + "&easy_sign_in=" + bech32_encoded_encrypted_privkey;
                showModal( `<p>Here is your easy sign in link:</p><p><a href="${url}">${url}</a></p><p>Just click it and then click Login. You'll never need to copy/paste your nsec again if you use that link and remember your username and password!</p>` );
            }
            var init = async () => {
                resizer();
                dotLoop( "." );
                if ( !$_GET[ "multisig" ] ) {
                    addNpub();
                    $( '.select_threshold' ).onchange = () => {
                        if ( isNaN( $( '.select_threshold' ).value ) ) return;
                        if ( Number( $( '.select_threshold' ).value ) > $$( '.select_npub' ).length ) $( '.select_threshold' ).value = $$( '.select_npub' ).length;
                        $( '.threshold_num' ).innerText = $( '.select_threshold' ).value;
                    }
                    $( '.select_threshold' ).onkeyup = () => {
                        if ( isNaN( $( '.select_threshold' ).value ) ) return;
                        if ( Number( $( '.select_threshold' ).value ) > $$( '.select_npub' ).length ) $( '.select_threshold' ).value = $$( '.select_npub' ).length;
                        $( '.threshold_num' ).innerText = $( '.select_threshold' ).value;
                    }
                    $( '.threshold_num' ).innerText = $( '.select_threshold' ).value;
                    $( '.create_bitpac' ).onclick = async () => {
                        var keep_going = true;
                        $$( '.select_npub' ).forEach( item => {
                            if ( !item.value ) {
                                keep_going = false;
                            }
                            if ( !isValidNpub( item.value ) ) {
                                keep_going = false;
                            }
                        });
                        if ( !keep_going ) {
                            showModal( "One of your npubs is invalid or empty, please fix it and try again" );
                            return;
                        }
                        var conf_message = `Are you sure you want to use a policy of ${String( $( '.select_threshold' ).value )} out of ${String( $$( '.select_npub' ).length )}?`;
                        var conf = confirm( conf_message );
                        if ( !conf ) return;
                        var npubs = [];
                        var pubkeys = [ Number( $( '.select_threshold' ).value ) ];
                        $$( '.select_npub' ).forEach( item => {
                            npubs.push( item.value );
                            pubkeys.push( pubkeyFromNpub( item.value ) );
                        });
                        var bitpac_name = $( '.bitpac_name' ).value;
                        var event = {
                            "content"    : JSON.stringify( [bitpac_name, pubkeys] ),
                            "created_at" : Math.floor( Date.now() / 1000 ),
                            "kind"       : 2858,
                            "tags"       : [],
                            "pubkey"     : pubKey,
                        }
                        var signedEvent = await getSignedEvent(event, privKey);
                        var note_id = signedEvent.id;
                        var divider = window.location.href.includes( "?" ) ? "&" : "?";
                        var url = window.location.href + divider + "multisig=" + note_id;
                        var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                            var myrelay = Object.keys( relays )[ i ];
                            if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                            relays[ myrelay ].addEventListener( "message", handleMessage );
                            relays[ myrelay ].send(JSON.stringify([ "EVENT", signedEvent ]));
                        }
                        showModal( `Success, your multisig is created and can be viewed and managed here:\n\n${url}` );
                    }
                } else {
                    $( '.multisig_creator' ).style.display = "none";
                    $( '.multisig_viewer' ).style.display = "block";
                    var i; for ( i=0; i<Object.keys( relays ).length; i++ ) {
                        var myrelay = Object.keys( relays )[ i ];
                        await waitForOneRelay();
                        if ( !relays[ myrelay ] || relays[ myrelay ].readyState != 1 ) continue;
                        if ( !$_GET[ "multisig"] ) continue;
                        relays[ myrelay ].addEventListener( "message", handleMessage );
                        var subId   = bytesToHex( nobleSecp256k1.utils.randomPrivateKey() ).toString( "hex" ).substring( 0, 24 );
                        var filter  = { "ids": [ $_GET[ "multisig"] ] }
                        var subscription = [ "REQ", subId, filter ];
                        relays[ myrelay ].send( JSON.stringify( subscription ) );
                    }
                }
            }
            getUtxosOnLoop = async () => {
                var num = Number( sessionStorage[ "loop_num" ] );
                if ( $( '.addy' ) && num < 1 ) {
                    getBitcoinPrice();
                    num = 10;
                    var utxos = await getUTXOs( $( '.addy' ).innerText, mempoolNetwork );
                    sessionStorage[ "utxos" ] = JSON.stringify( utxos );
                    var full_balance = 0;
                    utxos.forEach( item => {
                        full_balance = full_balance + item[ 2 ];
                    });
                    var usd_balance = await satsToDollars( full_balance );
                    usd_balance = usd_balance.toFixed( 2 );
                    $( '.bitpac_balance' ).innerText = usd_balance;
                    $$( '.bitpac_balance' )[ 1 ].innerText = usd_balance;
                    $( '.bitpac_balance_sats' ).innerText = full_balance;
                    $$( '.bitpac_balance_sats' )[ 1 ].innerText = full_balance;
                    Object.keys( relays ).forEach( item => {
                        fixReadyState( item );
                    });
                } else if ( num < 1 ) {
                    num = 10;
                    Object.keys( relays ).forEach( item => {
                        fixReadyState( item );
                    });
                }
                num = num - 1;
                sessionStorage[ "loop_num" ] = String( num );
                await waitSomeSeconds( 1 );
                getUtxosOnLoop();
            }
            init();
            sessionStorage[ "loop_num" ] = "3";
            getUtxosOnLoop();
        </script>
        <div class="black-bg" onclick="modalVanish();"></div>
        <div class="modal"></div>
    </body>
</html>
